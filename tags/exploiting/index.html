<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Tag: exploiting | 一生あとで読んでろ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="一生あとで読んでろ">
<meta property="og:url" content="http://ntddk.github.io/tags/exploiting/index.html">
<meta property="og:site_name" content="一生あとで読んでろ">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一生あとで読んでろ">
  
  
  <link href="//fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">一生あとで読んでろ</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技術ブログ</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-home-icon" class="nav-icon" href="/"></a>
        
          <a id="nav-about-icon" class="nav-icon" href="/about"></a>
        
        
      </nav>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-angr-afl-driller" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2016/08/27/angr-afl-driller/">angr, AFL, Driller</a>
  

      </header>
    
    <time class="article-date" datetime="2016-08-26T18:00:00.000Z" itemprop="datePublished">08-27-2016</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>　今年のセキュリティ・キャンプでは，うっかり「なぜマルウェア解析は自動化できないのか」という題の講義を行ってしまったが，それだけセキュリティの世界には自動化の波が来ている．本稿では，脆弱性分析の自動化をめざして開発されているangr, AFL, Drillerをざっくり紹介する．</p>
<h1 id="angr"><a href="#angr" class="headerlink" title="angr"></a>angr</h1><p>　<a href="http://angr.io/" target="_blank" rel="external">angr</a>はUCSBの研究チームにしてCTFチーム<a href="https://twitter.com/shellphish" target="_blank" rel="external">Shellphish</a>を中心に開発されているバイナリ解析フレームワーク．<a href="https://www.cs.ucsb.edu/~vigna/publications/2016_SP_angrSoK.pdf" target="_blank" rel="external">論文[PDF]</a>はIEEE S&amp;P 2016に採択されている．手法の新規性というよりは実装力でゴリ押しするタイプ．評価には，アメリカ国防高等研究計画局が5,500万ドル（約56億円）の資金を投じてまで開催した脆弱性分析・修正の自動化コンペ，<a href="https://www.cybergrandchallenge.com/" target="_blank" rel="external">DARPA Cyber Grand Challenge</a> (CGC) のデータセットが用いられている．CGCの決勝戦に進出したチームには75万ドル（約7,600万円），優勝したチームは200万ドル（約2億円）が与えられる．angr開発の目的のひとつが，CGCでの勝利にあることは疑いようもない——最終的な戦績は，CMUのツールMAYHEMに優勝を譲って3位だったが．<br>　さて，angrはシンボリック実行やプログラムスライシングを通して，<strong>プログラムの特定位置に到達するための入力値を抽出することができる</strong>．次のコードで雰囲気をつかめるだろうか：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment">#-*- coding:utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> angr</div><div class="line"><span class="keyword">import</span> simuvex</div><div class="line"></div><div class="line"><span class="comment"># 解析対象を指定</span></div><div class="line">p = angr.Project(sys.argv[<span class="number">1</span>]) </div><div class="line"></div><div class="line"><span class="comment"># 制御フローグラフの生成</span></div><div class="line">cfg = p.analyses.CFG()</div><div class="line"><span class="keyword">print</span> [x <span class="keyword">for</span> x <span class="keyword">in</span> cfg.functions.iteritems()]</div><div class="line"></div><div class="line"><span class="comment"># シンボルを取得</span></div><div class="line">target_addr = p.loader.main_bin.get_symbol(<span class="string">"main"</span>).addr</div><div class="line"></div><div class="line"><span class="comment"># パス分析クラスのインスタンス</span></div><div class="line">pg = p.factory.path_group()</div><div class="line"></div><div class="line"><span class="comment"># シンボルへのパスを分析</span></div><div class="line">pg.explore(find = target_addr)</div><div class="line"></div><div class="line"><span class="comment"># avoidを避け，findに到達する入力値を探索してくれる</span></div><div class="line">a = p.surveyors.Explorer(find = FIND_ADDR, avoid = AVOID_ADDR).run()</div><div class="line"></div><div class="line"><span class="comment"># フック</span></div><div class="line">p.hook_symbol(<span class="string">'strlen'</span>, simuvex.SimProcedures[<span class="string">'stubs'</span>][<span class="string">'ReturnUnconstrained'</span>])</div><div class="line"></div><div class="line"><span class="comment"># 実行結果のダンプ</span></div><div class="line">a.found[<span class="number">0</span>].state.posix.dumps(<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>　解析対象の規模が大きい場合，エントリポイントを起点とした解析に時間を要するあるいは失敗することがあるが，プログラムの途中から解析を始めることも可能だ．</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">p = angr.Project(sys.argv[<span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="comment"># 解析の起点となるアドレス</span></div><div class="line">state = p.factory.blank_state(addr = START_ADDR)</div><div class="line"><span class="comment"># その地点までプログラムを実行したときのスタックの状態</span></div><div class="line">state.regs.ebp = BASE_ADDR</div><div class="line">state.regs.esp = STACK_ADDR</div><div class="line"></div><div class="line"><span class="comment"># 入力値の設定</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(INPUT_LENGTH):</div><div class="line">    s = state.se.BVS(<span class="string">'Var[&#123;&#125;]'</span>.format(i), <span class="number">32</span>, explicit_name = <span class="keyword">True</span>)</div><div class="line">    state.memory.store(INPUT_ADDR + i * <span class="number">4</span>, s)</div><div class="line"></div><div class="line">path = p.factory.path(state)</div><div class="line">a = p.surveyors.Explorer(start = path, find= FIND_ADDR, avoid= AVOID_ADDR)</div><div class="line">a.found[<span class="number">0</span>].state.posix.dumps(<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>　シンボリック実行はSSA形式の中間表現を前提とするが，angrはValgrindのVEX IRを用いている．バックエンドのSMTソルバはZ3だが，claripyという自前のラッパが噛ませてある．<br>　これ以上の説明は<a href="http://docs.angr.io/" target="_blank" rel="external">公式ドキュメント</a>に譲ろう．</p>
<h1 id="AFL"><a href="#AFL" class="headerlink" title="AFL"></a>AFL</h1><p>　<a href="http://lcamtuf.coredump.cx/afl/" target="_blank" rel="external">AFL</a> (American Fuzzy Lop) はGoogleのエンジニア<a href="https://twitter.com/lcamtuf" target="_blank" rel="external">lcamtuf</a>を中心に開発されているファジングツール．遺伝的アルゴリズムによって正常な入力を次々と変異させていき，<strong>自動的にプログラムのバグを検出する</strong>．AFLにはbashやtcpdump, OpenSSHといったさまざまなソフトウェアのバグを検出した実績があり，いまや脆弱性分析の研究になくてはならない存在だ．一般的なファジングはプログラムの浅い箇所にしか到達できない．AFLは，大量の正常な入力をトリミングしてシードとするコーパス蒸留 (corpus distillation) と，遺伝的アルゴリズムを用いてシードを変異させる<a href="http://ieeexplore.ieee.org/document/4682289/" target="_blank" rel="external">GAFuzzing</a>のいいとこ取りを図ったものだ．その実行フローは次のようになる：</p>
<ol>
<li>ユーザーから与えられた初期テストケースをキューに入れる</li>
<li>キューから次の入力テストケースをひとつ取り出し，</li>
<li>プログラムの振る舞いに影響を与えない最小サイズにトリミングする</li>
<li>バランスのよい探索となるよう，さまざまな変異戦略を用いて入力を繰り返し変異させる</li>
<li>新たな状態遷移が計測されたら，出力をキューに入れる</li>
<li>2に戻る</li>
</ol>
<p>　ここでAFLはカバレッジ計測のため，解析対象のプログラムに計測用のコードを埋め込む．これには，解析対象のソースコードが手元にある場合gccやclangの独自フロントエンドが，解析対象のソースコードが手元にない場合QEMUが用いられる．<br>　ファジング機能の中核は，<code>afl-fuzz.c</code>の<code>main()</code>から呼び出される<code>fuzz_one()</code>にある．実装されている変異戦略は次の通り：</p>
<ul>
<li>SIMPLE BITFLIP</li>
<li>ARITHMETIC INC/DEC</li>
<li>INTERESTING VALUES</li>
<li>DICTIONARY STUFF</li>
<li>RANDOM HAVOC</li>
<li>SPLICING</li>
</ul>
<p>　CGCで優勝したCMUのMAYHEMは，<a href="https://twitter.com/thedavidbrumley/status/762107471771021313" target="_blank" rel="external">このAFLにシンボリック実行機能を追加していたようだ</a>．MAYHEMといえば同名のシンボリック実行エンジンの<a href="https://users.ece.cmu.edu/~arebert/papers/mayhem-oakland-12.pdf" target="_blank" rel="external">論文[PDF]</a>がIEEE S&amp;P 2012で発表されているが，当時からの変更点がどれほどなのかはわからない．<br>　また，AFLの拡張に，解析対象のパスを枝刈りすることで高速化を図った<a href="https://github.com/mboehme/aflfast" target="_blank" rel="external">AFLFast</a>がある．これもCGC決勝進出チームによるもので，<a href="https://comp.nus.edu.sg/~mboehme/paper/CCS16.pdf" target="_blank" rel="external">論文[PDF]</a>はACM CCS 2016に採択されている．600行程度のパッチでトップカンファレンス．ちょっと妬ましい．</p>
<h1 id="Driller"><a href="#Driller" class="headerlink" title="Driller"></a>Driller</h1><p>　<a href="https://github.com/shellphish/driller" target="_blank" rel="external">Driller</a>はangrの開発陣によるAFLの拡張．<a href="https://www.internetsociety.org/sites/default/files/blogs-media/driller-augmenting-fuzzing-through-selective-symbolic-execution.pdf" target="_blank" rel="external">論文[PDF]</a>はNDSS 2016に採択されている．AFLのREADMEには次のようにある：</p>
<blockquote>
<p>Other, more sophisticated research has focused on techniques such as program flow analysis (“concolic execution”), symbolic execution, or static analysis. All these methods are extremely promising in experimental settings, but tend to suffer from reliability and performance problems in practical uses - and currently do not offer a viable alternative to “dumb” fuzzing techniques.</p>
</blockquote>
<p>　シンボリック（コンコリック）実行は実用的ではないと切って捨てている．DrillerはangrとAFLを組み合わせることで，この批判を克服し，ファジングとシンボリック実行のいいとこ取りを図ったものだ：</p>
<p><img src="/image/driller/driller.png" width="100%" height="100%"></p>
<p>　たとえば，次のコードの解析には，ファジングよりシンボリック実行が適している：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> x;</div><div class="line">    read(<span class="number">0</span>, &amp;x, <span class="keyword">sizeof</span>(x));</div><div class="line">    <span class="keyword">if</span>(x == <span class="number">0x123ABCD</span>)</div><div class="line">        vulnerable();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　なぜなら，ファジングによって<code>0x123ABCD</code>という値を生成するには大量の試行を必要とするからだ．一方で，次のコードの解析には，シンボリック実行よりファジングが適している：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">char</span> *x, <span class="keyword">int</span> depth)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(depth &gt;= <span class="number">100</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">int</span> count = (*x == <span class="string">'B'</span>) ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">        count += check(x+<span class="number">1</span>, depth+<span class="number">1</span>);</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">char</span> x[<span class="number">100</span>];</div><div class="line">    read(<span class="number">0</span>, x, <span class="number">100</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(check(x, <span class="number">0</span>) == <span class="number">25</span>)</div><div class="line">        vulnerable();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　なぜなら，単純なシンボリック実行ではパス爆発を解決できないからだ．<br>　Drillerは両手法の長所と短所を踏まえた上で，それらを堅実に組み合わせている．やはりハッシュ関数の充足はDrillerをもってしても難しいようだが，現行MAYHEMもAFLとシンボリック実行を併用しているようだし，このアプローチが現在の着地点なのだろう．</p>
<h1 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h1><p>　CGCとそれにともなう研究によって，脆弱性分析の自動化手法は大きな進歩を遂げつつあることが伝わっただろうか．学会のOSS重視傾向も相まって，さまざまなツールを手元で試せるようになってきている．大変ありがたいことだ．</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2016/08/27/angr-afl-driller/" data-id="cj2mtsjl600068wos60sdxkke" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/exploiting/">exploiting</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/symbolic-execution/">symbolic execution</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-before-c-constructor" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2015/02/24/before-c-constructor/">__attribute__((constructor))が呼ばれる前に</a>
  

      </header>
    
    <time class="article-date" datetime="2015-02-24T13:46:08.000Z" itemprop="datePublished">02-24-2015</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="attribute-constructor"><a href="#attribute-constructor" class="headerlink" title="__attribute__((constructor))"></a><code>__attribute__((constructor))</code></h1><p><code>main()</code>が呼ばれる前に関数を呼ぶ方法として，一般にgcc拡張である<code>__attribute__((constructor))</code>が利用されている．<br>例えば次のコードでは，<code>main()</code>の前に<code>constructor()</code>が呼び出される．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">__attribute__((constructor)) void constructor()&#123;</div><div class="line">  printf(&quot;constructor\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">  printf(&quot;main\n&quot;);</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="libc-start-main"><a href="#libc-start-main" class="headerlink" title="__libc_start_main()"></a><code>__libc_start_main()</code></h1><p>gccが内部で呼び出すldは，glibcの初期化を行うためにcrt*.oを静的リンクする．これによって，<code>_start()</code>などのシンボルがバイナリに埋め込まれることになる．<br>ここで埋め込まれるシンボルには未定義なものが存在する．その一つとして，crt1.oに含まれる<code>__libc_start_main()</code>が挙げられる．<br>これは<code>main()</code>より先んじて呼び出される関数であり，暗黙的にcrt1.oがリンクの対象となる．しかし未定義であるがゆえに，先にソースコードに<code>__libc_start_main()</code>が宣言されていた場合，ldはこちらをシンボルとして採用してしまう．</p>
<h1 id="どちらが先か"><a href="#どちらが先か" class="headerlink" title="どちらが先か"></a>どちらが先か</h1><p>上記を踏まえて，次のコードではどちらの関数が先に呼び出されるだろうか．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">__attribute__((constructor)) void constructor()&#123;</div><div class="line">  printf(&quot;constructor\n&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">int __libc_start_main()&#123;</div><div class="line">  printf(&quot;__libc_start_main\n&quot;);</div><div class="line">  return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">  printf(&quot;main\n&quot;);</div><div class="line">  return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正解は<code>__libc_start_main()</code>だ．私は実行するまで分からなかった．</p>
<h1 id="do-global-ctors-aux"><a href="#do-global-ctors-aux" class="headerlink" title="__do_global_ctors_aux()"></a><code>__do_global_ctors_aux()</code></h1><p>なぜ<code>__libc_start_main()</code>が<code>__attribute__((constructor))</code>よりも先に呼び出されるのか．それは<code>__attribute__((constructor))</code>が，<code>__do_global_ctors_aux()</code>によって実現されているからだ．<br><code>__do_global_ctors_aux()</code>は<code>_start()</code>, <code>__libc_start_main()</code>, <code>__libc_csu_init()</code>, <code>_init()</code>を通ってようやく呼び出される．そのため，<code>__libc_start_main()</code>の方がより先んじて呼び出されるのだ．</p>
<h1 id="libc-csu-init"><a href="#libc-csu-init" class="headerlink" title="__libc_csu_init()"></a><code>__libc_csu_init()</code></h1><p>Sigreturn-oriented Programmingでにわかに脚光を浴びている<code>__libc_csu_init()</code>は<code>__libc_start_main()</code>の引数にセットされるコンストラクタだが，シンボルを上書きして<code>__libc_start_main()</code>の代わりにこちらを<code>main()</code>ないし<code>__attribute__((constructor))</code>の先に呼び出すこともできる．<br>当初私は<code>__attribute__((constructor))</code>はこの辺りから呼び出されるものだと誤解していた．</p>
<h1 id="Windowsでは"><a href="#Windowsでは" class="headerlink" title="Windowsでは"></a>Windowsでは</h1><p>今回は触れないが，<code>.CRT$X??</code>のセクションや<code>Thread Local Storage</code>のコールバックによって同様の機能を実現できる．</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li>高林哲, 鵜飼文敏, 佐藤祐介, 浜地慎一郎, 首藤 一幸,<br>“Binary Hacks - ハッカー秘伝のテクニック100選,”<br>オライリー・ジャパン, 2006.</li>
<li>“Linux x86 Program Start Up,”<br><a href="http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html" target="_blank" rel="external">http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2015/02/24/before-c-constructor/" data-id="cj2mtsjl6000a8wosrex2z9yz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/exploiting/">exploiting</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-pintool-nx" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2014/12/11/pintool-nx/">Intel PinにおけるNXの扱い</a>
  

      </header>
    
    <time class="article-date" datetime="2014-12-11T09:00:00.000Z" itemprop="datePublished">12-11-2014</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>2014.12.07~08にわたって開催されたSECCON CTF 2014の予選（英語版）にて，ROP: Impossibleというpwn問題が出題された．タイトルの通り，この問題ではROPが制限されている．<br>ここでは，その実現手法として用いられていたIntel Pin(pintool)について，またこの問題にあった欠陥について述べる．<br>したがって，このエントリはROP: Impossibleの<strong>ネタバレ</strong>を兼ねている．注意されたし．</p>
<h1 id="問題の概要"><a href="#問題の概要" class="headerlink" title="問題の概要"></a>問題の概要</h1><p>問題文は以下の通り．Pinによって保護された脆弱なバイナリからフラグを読み出せというものだ．</p>
<blockquote>
<p>ropi.pwn.seccon.jp:10000<br>read <code>/flag</code> and write the content to stdout, such as the following pseudo code.<br><code>open(&quot;/flag&quot;, 0);</code><br><code>read(3, buf, 32);</code><br><code>write(1, buf, 32);</code><br>Notice that the <code>vuln</code> executable is protected by an Intel Pin tool, the source code of which is <code>norop.cpp</code>.</p>
</blockquote>
<p>パッと見，バイナリは良心的な構成であるように思われる．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, for GNU/Linux 2.6.26, BuildID[sha1]=0xcb671b1dc0409082c3f3962818d366fcb8771ead, not stripped</div></pre></td></tr></table></figure></p>
<p>有効になっているのはNXだけだ．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE</div><div class="line">No RELRO        No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   vuln</div></pre></td></tr></table></figure></p>
<p>だからといって，解法が自明であるわけではない．この問題の肝は，いかにしてPinによる保護をかい潜るかにある．</p>
<h1 id="Pin"><a href="#Pin" class="headerlink" title="Pin"></a>Pin</h1><p>Pinは，Intelによって開発されたDBI(dynamic binary instrumentation)フレームワークである．<br>DBIとは，プログラムにコードを挿入することで実行時の情報を取得・操作する技術であり，プログラムのパフォーマンス測定やエラー検出，CPUキャッシュの分析や未定義命令のエミュレーションなど，多方面で応用されている．<br>さて，ROP: Impossibleは以下のコードによって保護されている．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &quot;pin.H&quot;</div><div class="line"></div><div class="line">ADDRINT	shadow_stack[4096];</div><div class="line">int		shadow_sp = -1;</div><div class="line"></div><div class="line">VOID push_retaddr(ADDRINT esp, ADDRINT eip)</div><div class="line">&#123;</div><div class="line">	if(shadow_sp &gt;= (int)sizeof(shadow_stack) - 1)&#123;</div><div class="line">		// cannot push retaddr to shadow stack</div><div class="line">		exit(-1);</div><div class="line">	&#125;</div><div class="line">	PIN_SafeCopy(&amp;shadow_stack[++shadow_sp], (VOID*)esp, sizeof(ADDRINT));</div><div class="line">&#125;</div><div class="line"></div><div class="line">VOID pop_retaddr(ADDRINT esp, ADDRINT eip)</div><div class="line">&#123;</div><div class="line">	ADDRINT		retaddr;</div><div class="line"></div><div class="line">	PIN_SafeCopy(&amp;retaddr, (VOID*)esp, sizeof(ADDRINT));</div><div class="line"></div><div class="line">	while(shadow_sp &gt;= 0 &amp;&amp; shadow_stack[shadow_sp--] != retaddr);</div><div class="line">	if(shadow_sp &lt; 0)&#123;</div><div class="line">		exit(-1);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">VOID check_syscall(ADDRINT eax)</div><div class="line">&#123;</div><div class="line">	switch(eax)&#123;</div><div class="line">	// syscalls for exploit</div><div class="line">	case 3:		// sys_read</div><div class="line">	case 4:		// sys_write</div><div class="line">	case 5:		// sys_open</div><div class="line">	case 6:		// sys_close</div><div class="line"></div><div class="line">	// syscalls executed until entry point</div><div class="line">	case 45:	// sys_brk</div><div class="line">	case 122:	// sys_newuname</div><div class="line">	case 192:	// sys_mmap2</div><div class="line">	case 197:	// sys_fstatfs64</div><div class="line">	case 243:	// sys_set_thread_area</div><div class="line">		break;</div><div class="line"></div><div class="line">	// invalid syscalls</div><div class="line">	default:</div><div class="line">		exit(-1);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">VOID insert_hooks(INS ins, VOID *val)</div><div class="line">&#123;</div><div class="line">	if(INS_IsCall(ins))&#123;</div><div class="line">		// push retaddr to shadow stack</div><div class="line">		if(XED_ICLASS_CALL_FAR == INS_Opcode(ins))&#123;</div><div class="line">			exit(-1);</div><div class="line">		&#125;</div><div class="line">		INS_InsertCall(ins, IPOINT_TAKEN_BRANCH,(AFUNPTR)push_retaddr,</div><div class="line">			IARG_REG_VALUE, REG_ESP, IARG_INST_PTR, IARG_END);</div><div class="line">	&#125;else if(INS_IsRet(ins))&#123;</div><div class="line">		// pop retaddr from shadow stack, and then check it</div><div class="line">		if(XED_ICLASS_RET_FAR == INS_Opcode(ins))&#123;</div><div class="line">			exit(-1);</div><div class="line">		&#125;else&#123;</div><div class="line">			INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)pop_retaddr,</div><div class="line">				IARG_REG_VALUE, REG_ESP, IARG_INST_PTR, IARG_END);</div><div class="line">		&#125;</div><div class="line">	&#125;else if(INS_IsSyscall(ins))&#123;</div><div class="line">		// check syscall</div><div class="line">		INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)check_syscall,</div><div class="line">			IARG_REG_VALUE, REG_EAX, IARG_END);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">	PIN_Init(argc, argv);</div><div class="line">	INS_AddInstrumentFunction(insert_hooks, NULL);</div><div class="line">    PIN_StartProgram();</div><div class="line">    </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>このプログラムが，vulnの共有ライブラリとして噛まされている．<code>INS_*</code>は命令単位のinstumentationのために提供されているPinのAPIである．<br>要するに，リターンアドレスの検証によって，ROPが制限されているのだ．</p>
<h1 id="JOP"><a href="#JOP" class="headerlink" title="JOP"></a>JOP</h1><p>ROPができない環境ならば，どうすればよいのか．<br>そもそも，ROPに用いられる<code>ret</code>は，スタックの最上位アドレスに対する<code>pop</code>と<code>jmp</code>と等価であると見做せる．ゆえに<code>jmp</code>によってchainを構築すれば，<code>ret</code>を用いること無くROPと同様なコードを作成することができる．これをJOP(Jump-oriented programming)という．<br>さらに，スタックに対するアドレスの<code>push</code>と<code>jmp</code>は，<code>call</code>と等価であると見做せる．ゆえに<code>call</code>と<code>pop</code>によってROPを代替することができる．<br>つまり，ROP: Impossibleは<code>ret</code>制限下の環境を前提に<code>jmp</code>と<code>call</code>でchainを構築しろというストイックな問題だった．<br>Pinに起因する欠陥がなければ．</p>
<h1 id="writeup"><a href="#writeup" class="headerlink" title="writeup"></a>writeup</h1><p>この問題を最初に解いたのは，TOEFL BEGINNERという謎のチームだった．続いてbinja, PPPと続いている．<br>優勝チームであるPPPメンバーのRicky Zhouが公開しているwriteupを見てみよう．</p>
<ul>
<li><a href="https://rzhou.org/~ricky/seccon2014/rop_impossible/" target="_blank" rel="external">Index of /~ricky/seccon2014/rop_impossible/</a></li>
</ul>
<p>明らかにおかしい．bssセグメントにシェルコードを置いて実行しているだけではないか．<br>だが，このバイナリはNXが有効だったはずだ．ローカルでこのコードを実行しても，SIGSEGVが発生する．<br>これは一体どうしたことだろう．</p>
<h1 id="JITコンパイルの弊害"><a href="#JITコンパイルの弊害" class="headerlink" title="JITコンパイルの弊害"></a>JITコンパイルの弊害</h1><p>結論から言うと，Pinの制御下にあるバイナリのNXは無効化されるようになっている．<br>/proc/pid/mapsを確認すると，一見nonexecであるように見える．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bf984000-bf9a5000 rw-p 00000000 00:00 0          [stack]</div></pre></td></tr></table></figure></p>
<p>だが，実際はそうではない．<br>PinはJITコンパイルによってinstrumentationを実現している．そのため，バイナリはPinによってmmapされ，execされる．このとき，Pinは元来バイナリに付与されていた実行権限を無視してしまう．<br>つまり，ROPを制限するためのPinが，NXを無効化してしまっていたのだ．<br>そもそも，LinuxにおいてNXの状態をmaps以外から取得するのは難しい．強いて挙げるならば，checksecのように<code>readelf -W -l file | grep &#39;GNU_STACK&#39;</code>を叩くといったところだろうか．だが，これだけではmmapやmprotectに追随することができない．WindowsのVirtualQueryに相当する機能はないのだろうか．</p>
<h1 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h1><p>XSS Bonsaiも同様だが，CTFについてもテストは重要であるということを気付かされた．<br>運営の穴を突くのもCTFの醍醐味のひとつなのだろうが，しかし厄介な問題である．<br>最近はPinやDynamoRioによるマルウェア解析が流行っているように見受けられるが，やがてはDBIツールのデメリットについても検討を加えなければならなくなるだろう．</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2014/12/11/pintool-nx/" data-id="cj2mtsjll000n8wos6b70utzv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/exploiting/">exploiting</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-after-rop" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2014/09/11/after-rop/">Return-oriented programming以後</a>
  

      </header>
    
    <time class="article-date" datetime="2014-09-11T10:07:12.000Z" itemprop="datePublished">09-11-2014</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>Return-oriented programming(ROP)が提唱されて久しい．CTFにおいても，ROPは当たり前のように要求される技術となってきている．一方で，ROPに代わる新たな攻撃手法も模索されている．ここでは，そういったROP以後の攻撃手法を概観する．</p>
<h1 id="Return-oriented-programming"><a href="#Return-oriented-programming" class="headerlink" title="Return-oriented programming"></a>Return-oriented programming</h1><h2 id="コンセプト"><a href="#コンセプト" class="headerlink" title="コンセプト"></a>コンセプト</h2><p>まずは簡単にROPをおさらいする．<br>ROPは主にハードウェアDEPという脆弱性対策技術に対抗するために編み出された攻撃手法である．ハードウェアDEPはCPUのNX bitを有効化することで，スタック上でコードを実行する攻撃を無効化する．<br>そこで，ROPはコード領域のretで終わる命令列(gadget)を実行することによってこれを回避する．単体のgadgetではわずかな処理しか行えないが，スタックに次のgadgetのアドレスを積むことで，gadgetを組み合わせたchainを構築することができる．ROPの作成にはコード領域からgadgetを探索する段階とgadgetを組み合わせる段階を要する．レジスタの操作はpopによって行う．</p>
<h2 id="ASLR-PIEの迂回"><a href="#ASLR-PIEの迂回" class="headerlink" title="ASLR/PIEの迂回"></a>ASLR/PIEの迂回</h2><p>ASLRはスタックやヒープなどが読み込まれる位置を実行ごとにランダマイズすることで，アドレスを決め打ちした攻撃を困難にする．だが，ASLRはROPに対処しうる技術ではない．<br>まず，LinuxにおいてASLRはコード領域のランダマイズを行わないため，スタックオーバーフローなどをROPの起点とすることができる．また，bssセグメントに存在する変数のアドレスを取得することができるのは，ASLRの重大な欠陥である．さらに，32bitの場合は総当りによってアドレスを特定できるほか，ulimit -s unlimitedによってASLRを無効化することができる．<br>PIEはASLRに加えてgadgetのアドレスまでランダマイズの対象となるため，攻撃にあたってはleakが前提となる．</p>
<h2 id="RELROの迂回"><a href="#RELROの迂回" class="headerlink" title="RELROの迂回"></a>RELROの迂回</h2><p>RELROはセクションをread onlyに設定する機能である．Partial RELROとFull RELROがあり，前者の場合はGOTを利用した攻撃が可能である．後者の場合はread onlyにしうる全てのセクションがread onlyとなるが，ROPによって攻撃を成立させることができる．</p>
<h2 id="Stager"><a href="#Stager" class="headerlink" title="Stager"></a>Stager</h2><p>攻撃に使える領域のサイズが制限されている場合，readなどの関数を用いて再度メモリに書き込む方法をstagerと呼ぶ．</p>
<h2 id="Stack-Pivot"><a href="#Stack-Pivot" class="headerlink" title="Stack Pivot"></a>Stack Pivot</h2><p>スタックのサイズ上，リターンアドレスの下にROP chainを構築できないような場合，xchg esp,eaxなどのgadgetを用いてスタックのアドレスを移動させる方法をstack pivotと呼ぶ．</p>
<h2 id="論文"><a href="#論文" class="headerlink" title="論文"></a>論文</h2><ul>
<li><a href="http://cseweb.ucsd.edu/~hovav/dist/geometry.pdf" target="_blank" rel="external">The Geometry of Innocent Flesh on the Bone: Return-into-libc without Function Calls (on the x86) [PDF]</a></li>
</ul>
<h1 id="BROP-Blind-return-oriented-programming"><a href="#BROP-Blind-return-oriented-programming" class="headerlink" title="BROP: Blind return-oriented programming"></a>BROP: Blind return-oriented programming</h1><h2 id="コンセプト-1"><a href="#コンセプト-1" class="headerlink" title="コンセプト"></a>コンセプト</h2><p>以下の要件を満たすサーバープログラムの場合は，バイナリが手元になくてもROPを試みることができる．</p>
<ul>
<li>listen，forkを行う</li>
<li>スタックオーバーフローで子プロセスが落ちた場合も動き続ける</li>
<li>GOTにstrcmpなど第三引数を操作できる関数が存在する</li>
<li>GOTにwriteなどleakさせることができる関数が存在する</li>
<li>総当りなどでGOTのアドレスが分かる</li>
</ul>
<p>目的は，自身をwriteによってダンプさせることである．<br>まず，リターンアドレスを総当りして，無限ループに陥るようなgadget(STOP gadgetと呼称)を探す．次に，関数にinnvalidな引数を渡した場合であっても，GOTに正しく飛んだ場合はSEGVしないという点に着目し，0x08040000周辺に存在しているはずのGOTセクションの位置を推定する．推定にあたっては，+0x6のアドレスや次のGOTエントリに飛んだ場合もSEGVしないという特性を用いる．そして，fdを総当りするか，多数のコネクションからwriteを探り当てる．<br>GOTエントリは要素数のサイズが同じであるため，スタックのleakからゴリ押しできる，といった内容のようだが，実際のところどうなのだろうか．CTFのネタとしては面白いのではないか．</p>
<h2 id="論文-1"><a href="#論文-1" class="headerlink" title="論文"></a>論文</h2><ul>
<li><a href="http://www.scs.stanford.edu/brop/bittau-brop.pdf" target="_blank" rel="external">Hacking Blind [PDF]</a></li>
</ul>
<h2 id="実例"><a href="#実例" class="headerlink" title="実例"></a>実例</h2><ul>
<li><a href="http://www.scs.stanford.edu/brop/braille.rb" target="_blank" rel="external">Braille [Ruby]</a></li>
</ul>
<h1 id="SROP-Sigreturn-oriented-Programming"><a href="#SROP-Sigreturn-oriented-Programming" class="headerlink" title="SROP: Sigreturn-oriented Programming"></a>SROP: Sigreturn-oriented Programming</h1><h2 id="コンセプト-2"><a href="#コンセプト-2" class="headerlink" title="コンセプト"></a>コンセプト</h2><p>vdsoには，シグナル割り込みから復帰する際に，ユーザーランドのスタック上に作成したsignal frameに保存している値を全てのレジスタへ戻すsigreturnという命令が存在する．つまり，popadが廃止されたx64においても，sigreturnによってスタック上の値を複数のレジスタにセットすることができる．これによって，任意のシステムコールを呼び出すことが可能となるほか，関数の呼び出しがレジスタ渡しの場合においてもROPが容易になる．なお，vsyscallはASLRが有効であっても固定アドレスである．<br>ulimit -s unlimitedを用いてvdsoのマッピングアドレスを固定できる場合はCTFでも活用できそうだ．</p>
<h2 id="論文-2"><a href="#論文-2" class="headerlink" title="論文"></a>論文</h2><ul>
<li><a href="https://www.cs.vu.nl/~herbertb/papers/srop_sp14.pdf" target="_blank" rel="external">Framing Signals—A Return to Portable Shellcode [PDF]</a></li>
</ul>
<h2 id="実例-1"><a href="#実例-1" class="headerlink" title="実例"></a>実例</h2><ul>
<li><a href="http://inaz2.hatenablog.com/entry/2014/07/30/021123" target="_blank" rel="external">x64でSigreturn Oriented ProgrammingによるASLR+DEP+RELRO回避をやってみる - ももいろテクノロジー</a></li>
</ul>
<h1 id="JOP-Jump-oriented-programmingとCOP-Call-oriented-programming"><a href="#JOP-Jump-oriented-programmingとCOP-Call-oriented-programming" class="headerlink" title="JOP: Jump-oriented programmingとCOP: Call-oriented programming"></a>JOP: Jump-oriented programmingとCOP: Call-oriented programming</h1><h2 id="コンセプト-3"><a href="#コンセプト-3" class="headerlink" title="コンセプト"></a>コンセプト</h2><p>通常，retの次にはそのサブルーチンを呼び出したcallの次の命令が存在する．そこで，コールスタックを辿ることでROPによってretが使われていないか検出するROPguardが考案された．ROPguardはMicrosoftの脆弱性対策ツールであるEMET 3.5の根幹を成す理論だった．<br>そこで，retの代わりにjmpを用いるJump-oriented programmingが考案された．また，retやjmpの代わりにcallを用いるCall-oriented programmingも可能である．例えば以下のコードスニペットにおいて，callはjmpと実質的に等価である．</p>
<pre><code>pop esi;
ret;
push eax;
call esi;

; call先
pop esi ;retアドレスを除去
;eaxを用いる処理
</code></pre><p>COPでは，pushのような表現力の高い命令を用いることができる．</p>
<h2 id="論文-3"><a href="#論文-3" class="headerlink" title="論文"></a>論文</h2><h3 id="ROPguard"><a href="#ROPguard" class="headerlink" title="ROPguard"></a>ROPguard</h3><ul>
<li><a href="http://ifsec.blogspot.jp/2012/08/my-bluehat-prize-entry-ropguard-runtime.html" target="_blank" rel="external">My BlueHat Prize entry: ROPGuard - runtime prevention of return-oriented programming attacks - Ivan Fratric’s Security Blog</a></li>
</ul>
<h3 id="JOP"><a href="#JOP" class="headerlink" title="JOP"></a>JOP</h3><ul>
<li><a href="ftp://ftp.ncsu.edu/pub/tech/2010/TR-2010-8.pdf" target="_blank" rel="external">Jump-Oriented Programming: A New Class of Code-Reuse Attack [PDF]</a></li>
</ul>
<h3 id="COP"><a href="#COP" class="headerlink" title="COP"></a>COP</h3><ul>
<li><a href="http://www.cs.stevens.edu/~gportoka/files/outofcontrol_oakland14.pdf" target="_blank" rel="external">Out of control: Overcoming control-flow integrity [PDF]</a></li>
<li><a href="http://www.cs.berkeley.edu/~daw/papers/rop-usenix14.pdf" target="_blank" rel="external">ROP is Still Dangerous: Breaking Modern Defenses [PDF]</a></li>
</ul>
<h2 id="実例-2"><a href="#実例-2" class="headerlink" title="実例"></a>実例</h2><h3 id="COP-1"><a href="#COP-1" class="headerlink" title="COP"></a>COP</h3><ul>
<li><a href="http://potetisensei.hatenablog.com/entry/2014/09/12/020720" target="_blank" rel="external">Call Oriented Programming - 生きたい</a></li>
</ul>
<h1 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h1><p>ざっとROP以後の攻撃手法を列挙した．これ以外にも，AlphanumericなROPを作成する技術やバイナリから自動的にROPを作成する技術などが研究されている．また，<a href="http://inaz2.hatenablog.com/entry/2014/08/03/230528" target="_blank" rel="external">roputils</a>や<a href="http://bap.ece.cmu.edu/" target="_blank" rel="external">BAP</a>など，ROPを支援するフレームワークも開発されている．これらについてもいずれ理解したい．</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2014/09/11/after-rop/" data-id="cj2mtsjkq00008wosv9m5q7x8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/exploiting/">exploiting</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 ntddk<br>
      <a href="https://github.com/ntddk/hexo-theme-jathena" target="_blank">JAthena</a> by <a href="https://ntddk.github.io" target="_blank">ntddk</a> | Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div>
</body>
</html>