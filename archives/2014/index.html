<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Archives: 2014 | 一生あとで読んでろ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="一生あとで読んでろ">
<meta property="og:url" content="http://ntddk.github.io/archives/2014/index.html">
<meta property="og:site_name" content="一生あとで読んでろ">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一生あとで読んでろ">
  
  
  <link href="//fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css">
  
</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">一生あとで読んでろ</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技術ブログ</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-home-icon" class="nav-icon" href="/"></a>
        
          <a id="nav-about-icon" class="nav-icon" href="/about"></a>
        
        
      </nav>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-pintool-nx" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2014/12/11/pintool-nx/">Intel PinにおけるNXの扱い</a>
  

      </header>
    
    <time class="article-date" datetime="2014-12-11T09:00:00.000Z" itemprop="datePublished">12-11-2014</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>2014.12.07~08にわたって開催されたSECCON CTF 2014の予選（英語版）にて，ROP: Impossibleというpwn問題が出題された．タイトルの通り，この問題ではROPが制限されている．<br>ここでは，その実現手法として用いられていたIntel Pin(pintool)について，またこの問題にあった欠陥について述べる．<br>したがって，このエントリはROP: Impossibleの<strong>ネタバレ</strong>を兼ねている．注意されたし．</p>
<h1 id="問題の概要"><a href="#問題の概要" class="headerlink" title="問題の概要"></a>問題の概要</h1><p>問題文は以下の通り．Pinによって保護された脆弱なバイナリからフラグを読み出せというものだ．</p>
<blockquote>
<p>ropi.pwn.seccon.jp:10000<br>read <code>/flag</code> and write the content to stdout, such as the following pseudo code.<br><code>open(&quot;/flag&quot;, 0);</code><br><code>read(3, buf, 32);</code><br><code>write(1, buf, 32);</code><br>Notice that the <code>vuln</code> executable is protected by an Intel Pin tool, the source code of which is <code>norop.cpp</code>.</p>
</blockquote>
<p>パッと見，バイナリは良心的な構成であるように思われる．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vuln: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, for GNU/Linux 2.6.26, BuildID[sha1]=0xcb671b1dc0409082c3f3962818d366fcb8771ead, not stripped</div></pre></td></tr></table></figure></p>
<p>有効になっているのはNXだけだ．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE</div><div class="line">No RELRO        No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   vuln</div></pre></td></tr></table></figure></p>
<p>だからといって，解法が自明であるわけではない．この問題の肝は，いかにしてPinによる保護をかい潜るかにある．</p>
<h1 id="Pin"><a href="#Pin" class="headerlink" title="Pin"></a>Pin</h1><p>Pinは，Intelによって開発されたDBI(dynamic binary instrumentation)フレームワークである．<br>DBIとは，プログラムにコードを挿入することで実行時の情報を取得・操作する技術であり，プログラムのパフォーマンス測定やエラー検出，CPUキャッシュの分析や未定義命令のエミュレーションなど，多方面で応用されている．<br>さて，ROP: Impossibleは以下のコードによって保護されている．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &quot;pin.H&quot;</div><div class="line"></div><div class="line">ADDRINT	shadow_stack[4096];</div><div class="line">int		shadow_sp = -1;</div><div class="line"></div><div class="line">VOID push_retaddr(ADDRINT esp, ADDRINT eip)</div><div class="line">&#123;</div><div class="line">	if(shadow_sp &gt;= (int)sizeof(shadow_stack) - 1)&#123;</div><div class="line">		// cannot push retaddr to shadow stack</div><div class="line">		exit(-1);</div><div class="line">	&#125;</div><div class="line">	PIN_SafeCopy(&amp;shadow_stack[++shadow_sp], (VOID*)esp, sizeof(ADDRINT));</div><div class="line">&#125;</div><div class="line"></div><div class="line">VOID pop_retaddr(ADDRINT esp, ADDRINT eip)</div><div class="line">&#123;</div><div class="line">	ADDRINT		retaddr;</div><div class="line"></div><div class="line">	PIN_SafeCopy(&amp;retaddr, (VOID*)esp, sizeof(ADDRINT));</div><div class="line"></div><div class="line">	while(shadow_sp &gt;= 0 &amp;&amp; shadow_stack[shadow_sp--] != retaddr);</div><div class="line">	if(shadow_sp &lt; 0)&#123;</div><div class="line">		exit(-1);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">VOID check_syscall(ADDRINT eax)</div><div class="line">&#123;</div><div class="line">	switch(eax)&#123;</div><div class="line">	// syscalls for exploit</div><div class="line">	case 3:		// sys_read</div><div class="line">	case 4:		// sys_write</div><div class="line">	case 5:		// sys_open</div><div class="line">	case 6:		// sys_close</div><div class="line"></div><div class="line">	// syscalls executed until entry point</div><div class="line">	case 45:	// sys_brk</div><div class="line">	case 122:	// sys_newuname</div><div class="line">	case 192:	// sys_mmap2</div><div class="line">	case 197:	// sys_fstatfs64</div><div class="line">	case 243:	// sys_set_thread_area</div><div class="line">		break;</div><div class="line"></div><div class="line">	// invalid syscalls</div><div class="line">	default:</div><div class="line">		exit(-1);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">VOID insert_hooks(INS ins, VOID *val)</div><div class="line">&#123;</div><div class="line">	if(INS_IsCall(ins))&#123;</div><div class="line">		// push retaddr to shadow stack</div><div class="line">		if(XED_ICLASS_CALL_FAR == INS_Opcode(ins))&#123;</div><div class="line">			exit(-1);</div><div class="line">		&#125;</div><div class="line">		INS_InsertCall(ins, IPOINT_TAKEN_BRANCH,(AFUNPTR)push_retaddr,</div><div class="line">			IARG_REG_VALUE, REG_ESP, IARG_INST_PTR, IARG_END);</div><div class="line">	&#125;else if(INS_IsRet(ins))&#123;</div><div class="line">		// pop retaddr from shadow stack, and then check it</div><div class="line">		if(XED_ICLASS_RET_FAR == INS_Opcode(ins))&#123;</div><div class="line">			exit(-1);</div><div class="line">		&#125;else&#123;</div><div class="line">			INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)pop_retaddr,</div><div class="line">				IARG_REG_VALUE, REG_ESP, IARG_INST_PTR, IARG_END);</div><div class="line">		&#125;</div><div class="line">	&#125;else if(INS_IsSyscall(ins))&#123;</div><div class="line">		// check syscall</div><div class="line">		INS_InsertCall(ins, IPOINT_BEFORE, (AFUNPTR)check_syscall,</div><div class="line">			IARG_REG_VALUE, REG_EAX, IARG_END);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">	PIN_Init(argc, argv);</div><div class="line">	INS_AddInstrumentFunction(insert_hooks, NULL);</div><div class="line">    PIN_StartProgram();</div><div class="line">    </div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>このプログラムが，vulnの共有ライブラリとして噛まされている．<code>INS_*</code>は命令単位のinstumentationのために提供されているPinのAPIである．<br>要するに，リターンアドレスの検証によって，ROPが制限されているのだ．</p>
<h1 id="JOP"><a href="#JOP" class="headerlink" title="JOP"></a>JOP</h1><p>ROPができない環境ならば，どうすればよいのか．<br>そもそも，ROPに用いられる<code>ret</code>は，スタックの最上位アドレスに対する<code>pop</code>と<code>jmp</code>と等価であると見做せる．ゆえに<code>jmp</code>によってchainを構築すれば，<code>ret</code>を用いること無くROPと同様なコードを作成することができる．これをJOP(Jump-oriented programming)という．<br>さらに，スタックに対するアドレスの<code>push</code>と<code>jmp</code>は，<code>call</code>と等価であると見做せる．ゆえに<code>call</code>と<code>pop</code>によってROPを代替することができる．<br>つまり，ROP: Impossibleは<code>ret</code>制限下の環境を前提に<code>jmp</code>と<code>call</code>でchainを構築しろというストイックな問題だった．<br>Pinに起因する欠陥がなければ．</p>
<h1 id="writeup"><a href="#writeup" class="headerlink" title="writeup"></a>writeup</h1><p>この問題を最初に解いたのは，TOEFL BEGINNERという謎のチームだった．続いてbinja, PPPと続いている．<br>優勝チームであるPPPメンバーのRicky Zhouが公開しているwriteupを見てみよう．</p>
<ul>
<li><a href="https://rzhou.org/~ricky/seccon2014/rop_impossible/" target="_blank" rel="external">Index of /~ricky/seccon2014/rop_impossible/</a></li>
</ul>
<p>明らかにおかしい．bssセグメントにシェルコードを置いて実行しているだけではないか．<br>だが，このバイナリはNXが有効だったはずだ．ローカルでこのコードを実行しても，SIGSEGVが発生する．<br>これは一体どうしたことだろう．</p>
<h1 id="JITコンパイルの弊害"><a href="#JITコンパイルの弊害" class="headerlink" title="JITコンパイルの弊害"></a>JITコンパイルの弊害</h1><p>結論から言うと，Pinの制御下にあるバイナリのNXは無効化されるようになっている．<br>/proc/pid/mapsを確認すると，一見nonexecであるように見える．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bf984000-bf9a5000 rw-p 00000000 00:00 0          [stack]</div></pre></td></tr></table></figure></p>
<p>だが，実際はそうではない．<br>PinはJITコンパイルによってinstrumentationを実現している．そのため，バイナリはPinによってmmapされ，execされる．このとき，Pinは元来バイナリに付与されていた実行権限を無視してしまう．<br>つまり，ROPを制限するためのPinが，NXを無効化してしまっていたのだ．<br>そもそも，LinuxにおいてNXの状態をmaps以外から取得するのは難しい．強いて挙げるならば，checksecのように<code>readelf -W -l file | grep &#39;GNU_STACK&#39;</code>を叩くといったところだろうか．だが，これだけではmmapやmprotectに追随することができない．WindowsのVirtualQueryに相当する機能はないのだろうか．</p>
<h1 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h1><p>XSS Bonsaiも同様だが，CTFについてもテストは重要であるということを気付かされた．<br>運営の穴を突くのもCTFの醍醐味のひとつなのだろうが，しかし厄介な問題である．<br>最近はPinやDynamoRioによるマルウェア解析が流行っているように見受けられるが，やがてはDBIツールのデメリットについても検討を加えなければならなくなるだろう．</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2014/12/11/pintool-nx/" data-id="cj9qzc73c000oeu7t3mgzp7cz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/exploitation/">exploitation</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-v2e" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2014/12/09/v2e/">マルウェア解析におけるRecord and Replayの設計</a>
  

      </header>
    
    <time class="article-date" datetime="2014-12-09T09:00:00.000Z" itemprop="datePublished">12-09-2014</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>“<a href="http://www.cl.cam.ac.uk/research/srg/netos/vee_2012/papers/p227.pdf" target="_blank" rel="external">V2E: Combining Hardware Virtualization and Software Emulation for Transparent and Extensible Malware Analysis[PDF]</a>“という論文を通して，Record and Replayを用いた解析環境の設計を学ぶ．</p>
<h1 id="著者"><a href="#著者" class="headerlink" title="著者"></a>著者</h1><p>この論文のラストオーサーであるYinはSyracuse Universityの助教である．彼はテイント解析の第一人者として知られ，現在は<a href="https://code.google.com/p/decaf-platform/" target="_blank" rel="external">DECAF</a>の開発を主導している．またBitBlaze ProjectのDawn Songや，マルウェア解析の大御所であるChristopher Kruegelと過去に共著を出している．<br>ファーストオーサーのYanは提案手法をAndroidに適用し，2013年に博士論文を著している．Android向けの拡張にあたっては，DECAFのサブプロジェクトであるDroidScopeを用いているようだ．</p>
<h1 id="Record-and-Replay"><a href="#Record-and-Replay" class="headerlink" title="Record and Replay"></a>Record and Replay</h1><p>あるいはLogging and Replay, Lockstep, 順序再演法，最小情報トレースなどと呼ばれるこれらは，仮想マシンモニタ上のイベントを記録し，再生するための技術である．乱暴に言うとhistoryからdockerfileやvagrantfileを作成し，deployするようなものだ．<br>一般にステートマシンにおける命令の出力は，内部状態から一意に与えられる．そこで，ある環境の初期状態と入力のみを記録(Record)し，同じ環境を別の環境の上に再生(Raplay)するといった試みがなされてきた．実マシンにおいては，時刻や割り込みなどの非決定性とその記録の困難性からRecord and Replayは不可能であるとされる．だが，仮想マシンモニタの世界ではこれらの問題をある程度無視できる．実際，VMware Workstationなどにこの機能は実装されている．<br>本論文では，マルウェア解析に求められるサンドボックスの特性を加味したRecord and Replayについて論じられている．かつて大居さん(<a href="https://twitter.com/a4lg" target="_blank" rel="external">@a4lg</a>)が研究されていた内容に近い．</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>マルウェアを解析するためのサンドボックスは検出不可能(transparent)であり，なおかつ拡張可能であるべきだ．<br>いかに仮想マシンモニタの存在を隠蔽しようと，Timing Attackなどが成り立つ以上，transparentなサンドボックスを実現することは不可能である．しかし，Intel VTなどハードウェア仮想化技術を用いることで，ほぼtransparentな環境を作り出すことは可能である．例えば，<a href="http://ether.gtisc.gatech.edu/" target="_blank" rel="external">Ether</a>は命令・システムコール単位の解析機能を備えているが，Xenをベースに高いtransparent性を実現している．<br>だが，ハードウェア仮想化技術に依存した解析環境には拡張性の点で問題がある．特に，instrumentationによる詳細な解析が不可能であるという点は，大きな痛手である．<br>他方，QEMUなどのソフトウェアエミュレーションは動的バイナリ変換を用いることでDBI(dynamic binary instrumentation)と解析効率の向上を実現している．しかし，transparentなサンドボックスには至れない．<br>QEMUの動的バイナリ変換はバイナリをコードブロック単位で変換し，softmmuからTLBを参照してアドレス変換を行うというものだ．<br>そしてその性質から，以下のような自己書き換えコードによって検出されうる．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">__asm&#123;</div><div class="line">	xor eax, eax</div><div class="line">	mov edi, target</div><div class="line">	mov esi, copy_insn</div><div class="line">	mov ecx, 3</div><div class="line"></div><div class="line">target:</div><div class="line">	rep movsw		// f3 66 a5</div><div class="line">	jmp qemu_found		// eb XX</div><div class="line">	nop			// 90</div><div class="line"></div><div class="line">non_qemu:</div><div class="line">	...</div><div class="line"></div><div class="line">qemu_found:</div><div class="line">	...</div><div class="line"></div><div class="line">copy_insn:</div><div class="line">	_emit 0xeb		// eb</div><div class="line">	_emit 0x01		// 01</div><div class="line">	_emit 0x90		// 90</div><div class="line">	_emit 0xeb</div><div class="line">	_emit 0x01</div><div class="line">	_emit 0x90</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>実マシンでは，<code>ecx*word=6</code>バイトが1回で書き換わるが，QEMUの動的バイナリ変換では2バイトずつ3回で書き換わる．そのため，1回目の書き換えで<code>0xeb 0x01 0xa5</code>すなわち<code>jmp +01</code>になってしまい，<code>qemu_found</code>にジャンプしてしまう．<br>その他には，ページ境界を越えてブロックの変換が行われた場合にページフォルトが発生してしまうことも考えられるし，ブロック境界でのみ割り込みが行われる，CPUサイクルの消費が著しいといった実マシンとの相違点もある．<br>さらに問題なのが，フラグの遅延評価だ．例えば，<code>cmp</code>と<code>jz</code>の組み合わせなどの条件分岐は，EFLAGSを更新する．だが，QEMUにおいては<code>cmp</code>が実行される段階でEFLAGSの計算は行われない．実際に計算されるのは<code>jz</code>の実行時，それも分岐を決定するためのZFのみが計算される．この設計はエミュレーションの高速化に寄与しているが，もちろん検出に用いることが可能だ．<br>当然ながら命令のエミュレーション自体にも限界がある．SIMDさえ厳しいのだ，システム管理モードやIntel TXTなんてものは考えたくないだろう．<br>このように，QEMUによるエミュレーションが検出される余地は枚挙に暇がない．<br>なお，解析環境検出をテーマとした最近の研究では，第2回システム系論文輪読会で<a href="http://ntddk.github.io/barecloud/">紹介した</a>BareCloudや忠鉢さん(<a href="https://twitter.com/yuzuhara" target="_blank" rel="external">@yuzuhara</a>)のTENTACLEなどがある．</p>
<h1 id="研究目的"><a href="#研究目的" class="headerlink" title="研究目的"></a>研究目的</h1><p>ハードウェア仮想化技術を用いる解析環境とソフトウェアエミュレーションを用いる解析環境にはそれぞれ問題がある．そこで，ハードウェア仮想化技術を用いる解析環境でRecordを行い，ソフトウェアエミュレーションを用いる解析環境でReplayを行うことで，検出不可能性と拡張可能性という二つの目的について達成したのが，今回紹介するV2Eである．</p>
<h1 id="形式的定義"><a href="#形式的定義" class="headerlink" title="形式的定義"></a>形式的定義</h1><p>本論文におけるRecord and Replayの設計はどのようなものか．<br>Recorderにおける遷移関数<code>f</code>について，毎時<sub><code>i</code></sub>におけるプログラムの状態を<code>S</code><sub><code>i</code></sub>とし，入力を<code>I</code><sub><code>i</code></sub>とする．すなわち<code>f</code>は<code>S</code><sub><code>i</code></sub><code>= f(S</code><sub><code>i-1</code></sub><code>, I</code><sub><code>i-1</code></sub><code>)</code>と表される．<br>次にReplayerにおける遷移関数<code>f&#39;</code>についてプログラムの初期状態を<code>S</code><sub><code>0</code></sub>とし，全ての入力を<code>I</code>としたとき，<code>f = f&#39;</code>と言えないだろうか．<br>これは二つのチューリング機械の同値性が解決可能であるかという問題に相当する．だが<code>EQ</code><sub><code>TM</code></sub><code>= {(M</code><sub><code>1</code></sub><code>, M</code><sub><code>2</code></sub>)<code>|M</code><sub><code>1</code></sub><code>とM</code><sub><code>2</code></sub><code>はTMであり，L(M</code><sub><code>1</code></sub><code>) = L(M</code><sub><code>2</code></sub><code>)}</code>は判定不可能とされ（『計算理論の基礎』における定理5.4），実装上でもハードウェアの割り込みなどの要因から<code>f != f&#39;</code>となってしまう．<br>そこでV2Eは，プログラムの初期状態と全ての入力を保存することに加え，<code>S</code><sub><code>j</code></sub><code>= S&#39;</code><sub><code>j</code></sub>となるような<sub><code>j</code></sub>について状態の変化を保存することにした．これは<code>⊿</code><sub><code>j</code></sub><code>= S</code><sub><code>j</code></sub><code>- S</code><sub><code>j-1</code></sub>と表される．<br>ここで，新たな遷移関数<code>f&#39;</code><sub><code>r</code></sub>を<code>S&#39;</code><sub><code>i</code></sub><code>= f&#39;</code><sub><code>r</code></sub><code>(S&#39;</code><sub><code>i-1</code></sub><code>, I</code><sub><code>i-1</code></sub><code>, ⊿</code><sub><code>i</code></sub><code>)</code>として定義する．これは，<code>⊿</code><sub><code>i</code></sub><code>!= null</code>のとき<code>S&#39;</code><sub><code>i-1</code></sub><code>+ ⊿</code><sub><code>i</code></sub>と同値であり，それ以外について<code>f&#39;(S</code><sub><code>i-1</code></sub><code>, I</code><sub><code>i-1</code></sub><code>)</code>と同値をとる．<br>なお，<code>S</code><sub><code>0</code></sub>, <code>I</code>, <code>⊿</code>および<code>f&#39;</code><sub><code>r</code></sub>, <code>S&#39;</code><sub><code>i</code></sub><code>= S</code><sub><code>i</code></sub>は<code>i ∈ [0, n]</code>について恒真である．<br>これを実装に起こすと，特定の命令やイベントが正しくエミュレート可能な場合は単にそれらをエミュレートし，そうでなければ状態の変化を記録し，Replayにあたって変更を適用するというアプローチになる．</p>
<h1 id="理論と実際"><a href="#理論と実際" class="headerlink" title="理論と実際"></a>理論と実際</h1><p>プログラムの大部分を占める<code>mov</code>, <code>push</code>, <code>pop</code>などのデータ転送命令，<code>call</code>, <code>ret</code>, <code>jz</code>, <code>jmp</code>などの制御転送命令，<code>add</code>, <code>shl</code>などの整数演算命令におけるエミュレーションは失敗しないものと見做せる．これらはそのままRecorderでエミュレートされる．<br>一方で，割り込み，MMIO, Port IO, DMA, TSCについては，V2Eは既存研究を踏襲し，監視領域においてのみこれらをRecordするようになっている．<br>では，例外，モデル固有レジスタ，<code>cpuid</code>はどうすべきだろうか．既存手法は，これらのエミュレーションは困難であるという理由から，そもそも入力として扱わない戦略を採っていたようだ．V2Eではこれらを<code>⊿</code>, すなわちエミュレートが困難な状態の変化としてRecordすることで，Replayの正確性を高めている．<br>次に問題となるのが浮動小数点演算とSIMDの扱いだ．MMXやSSEを正確にエミュレートするのは難しい．だが，<code>⊿</code>として命令の結果を記録する設計は大幅なパフォーマンスの低下を招く．そこでV2EはReplayにあたってこれらの命令をパススルーする．もちろん，ReplayerはSIMDをサポートしているマシンで実行されることが前提にある．</p>
<h1 id="Transparent-Recorder"><a href="#Transparent-Recorder" class="headerlink" title="Transparent Recorder"></a>Transparent Recorder</h1><p>RecorderはKVMを用いて実装されている．<br>V2EはRecord対象の領域とそれ以外のシステムを分割するため，TDP(two dimensional paging)を用いている．何のことかと思ったら，Intel EPTやAMD NPTの総称らしい．<br><img src="/image/tdp.jpg"><br>要するに，TDPとは仮想マシンと物理マシン間のページテーブルのことだ．通常のページングでは，メモリアクセスに応じてMMUによってページテーブルが参照され，仮想アドレスが物理アドレスへと変換される．TDPでは，ゲストマシンからの仮想メモリ空間へのアクセスに応じてCR3にセットされたページテーブルが参照され，ゲスト物理アドレスがホスト物理アドレスへと変換される．<br>この仕組を用いたV2Eは，<strong>監視対象用のTDPテーブルと，それ以外用のTDPテーブルを別々に作成する</strong>．マルウェアに属するページはCR3の監視に基づき監視対象用のTDPテーブルに書き込まれる．マルウェアとそれ以外の部分のインタラクションはTDPページフォルトや<code>VMExit</code>によって媒介される．共有されるデータは読み取り専用として双方に与えられる．なお，TDPページフォルトに応じてCPUの状態が入力<code>I</code><sub><code>i</code></sub>として保存される．</p>
<h1 id="Precise-Replayer"><a href="#Precise-Replayer" class="headerlink" title="Precise Replayer"></a>Precise Replayer</h1><p>ReplayerはTEMUを用いて実装されている．バイナリ変換器に中間表現がなく，単純に古いQEMU 0.9.1をベースとしているのが玉に瑕だが，TEMUは動的テイント解析に求められる機能をほぼ網羅している．<br>TEMUはプラグインを共有ライブラリとしてロードし，コールバック関数からテイント解析の機能を呼び出すプラットフォームとなっている．V2EのReplayerは既存のプラグインであるtracecap, unpackerを用いる．だがRecordされたログには監視対象の情報のみが記述されているため，<br><code>return ((*TEMU_cpu_hflags &amp; HF_CPL_MASK) != 3)</code>といった，現在実行しているコードが解析対象のものかどうか判定するコードは除去されているようだ．TEMUのプラグインについては，こうした僅かな変更しか施されていない．<br>一方でその下で動くQEMUには結構手が加えられている．フラグの遅延評価は廃止され，ページフォルト以外の例外は除去されており，SIMDについては独自のヘルパー関数が追加されたようだ．QEMUのdyngenに手を加えるのはなかなか骨の折れる作業だと思う．<br>さて，Replayを行うためには，ReplayerはRecorderと同様のページングの仕組みをエミュレーションによって再現しなければならない．そこで，V2Eは物理ページコンテナという仕組みを用いている．これは，物理ページがログからロードされていることを示すものである．通常，物理ページコンテナは監視対象用のTDPテーブルを複製する．Replayされたプログラムが物理ページコンテナに存在しないページにアクセスした場合，Replayerは適切なタイミングでログからCPUの状態を復元し，ロードするようになっている．<br>V2Eにおけるテイント解析はおそらく，マルウェアのメモリ領域を正確に把握するためのものではない．それは，Recorderの段階でTDPテーブルの分割というアプローチによって実現されるべきものだからだ．TEMUのプラグインを使いたかったのだろうが，論文中からはあまりテイント解析を導入することのメリットが読み取れなかった．ここでのテイント解析は解析環境検出の対策に先立つものとして設定されているのだろうか．</p>
<h1 id="評価"><a href="#評価" class="headerlink" title="評価"></a>評価</h1><p>解析環境検出については問題なし．<code>cpuid</code>, <code>rdtsc</code>, <code>cmpxch8b</code>, <code>icbp</code>, <code>rep stosb</code>, <code>fnstcw</code>といった命令や，一般保護例外などについてテストされている．なお，<code>rdtsc</code>については<code>VMRESUME</code>前にホストのTSCを参照することで対応している．<br>in-the-wildのマルウェアについても実験が行われており，アンパッカーとして期待できるパフォーマンスを見せている．<br>Recordにおける速度だが，コンテキストスイッチが頻繁に発生するカーネルモードルートキットで17倍，Internet Explorerで5倍と高速だ．KVMのシングルステップモードには3000倍のオーバーヘッドがあると言うのに．<br>全体的にpositiveな結果で，かなり良い．</p>
<h1 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h1><p>マルウェアによる解析環境検出に対して，復数の環境を組み合わせたRecord and Replayを用いる研究について紹介した．何より，監視対象とそれ以外で別個にTDPテーブルを作るというアプローチが素晴らしい．自分も研究でテイント解析を扱っているが，この流れを包摂していきたい．<br>ただ，これはサンドボックス全般に言えることなのだが，感染ホストにおけるユーザーのブラウザ操作が条件分岐に影響するMITBマルウェアについて，どう対処すべきなのだろうか．正常系のユーザーのブラウザ操作をデータセットとしてRecorderに与えたいところだが，果たしてどうなるのか．<br>このエントリは<a href="http://www.adventar.org/calendars/440" target="_blank" rel="external">システム系論文紹介 Advent Calendar 2014</a>の9日目として書かれた．</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li>Lok-Kwong Yan, Manjukumar Jayachandra, Mu Zhang and Heng Yin,<br>“<a href="http://www.cl.cam.ac.uk/research/srg/netos/vee_2012/papers/p227.pdf" target="_blank" rel="external">V2E: Combining Hardware Virtualization and Software Emulation for Transparent and Extensible Malware Analysis[PDF]</a>,”<br>Proceedings of the 8th ACM SIGPLAN/SIGOPS conference on Virtual Execution Environments, pp. 227-238, NY, USA, 2012.</li>
<li>George W. Dunlap, Samuel T. King, Sukru Cinar, Murtaza A. Basrai and Peter M. Chen,<br>“<a href="http://web.engr.illinois.edu/~kingst/Research_files/dunlap02.pdf" target="_blank" rel="external">ReVirt: Enabling Intrusion Analysis through Virtual-Machine Logging and Replay[PDF]</a>,”<br>Proceedings of the 2002 Symposium on Operating Systems Design and Implementation, pp. 211-224, NY, USA, 2002.</li>
<li>A. Dinaburg, P. Royal, M. Sharif and W. Lee.<br>“<a href="http://ether.gtisc.gatech.edu/ether_ccs_2008.pdf" target="_blank" rel="external">Ether: malware analysis via hardware virtualization extensions[PDF]</a>,”<br>Proceedings of the 15th ACM Conference on Computer and Communications Security, pp. 51–62, NY, USA, 2008.</li>
<li>大居司,<br>“<a href="http://www.slideshare.net/a4lg/a-new-tracer-for-reverse-engineering" target="_blank" rel="external">リバースエンジニアリングのための新しいトレース手法</a>,”<br>PacSec 2010, 東京, 日本, 2010.</li>
<li>Dhilung Kirat, Giovanni Vigna, and Christopher Kruegel,<br>“<a href="https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-kirat.pdf" target="_blank" rel="external">BareCloud: Bare-metal Analysis-based Evasive Malware Detection[PDF]</a>,”<br>Proceedings of the 23rd USENIX conference on Security Symposium, pp. 287-301, CA, USA, 2014.</li>
<li>忠鉢洋輔, 愛甲健二,<br>“<a href="https://pacsec.jp/psj14/PSJ2014_chubachi_final_ja.pdf" target="_blank" rel="external">TENTACLE: Environment-Sensitive Malware Palpation[PDF]</a>,”<br>PacSec Tokyo 2014, 東京, 日本, 2014.</li>
<li>M. Siper,<br>“<a href="http://www.cs.virginia.edu/~robins/Sipser_2006_Second_Edition_Problems.pdf" target="_blank" rel="external">Introduction to the Theory of Computation. International</a>,”<br>Thomson Publishing, 1996.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2014/12/09/v2e/" data-id="cj9qzc73l001geu7tdqboybsr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-binary-translation/">dynamic binary translation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/symbolic-execution/">symbolic execution</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/taint-analysis/">taint analysis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/virtual-machine-introspection/">virtual machine introspection</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-symexec-s2e" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2014/12/03/symexec-s2e/">選択的シンボリック実行ツールS2E</a>
  

      </header>
    
    <time class="article-date" datetime="2014-12-03T14:00:00.000Z" itemprop="datePublished">12-03-2014</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>選択的シンボリック実行について紹介する．</p>
<h1 id="シンボリック実行"><a href="#シンボリック実行" class="headerlink" title="シンボリック実行"></a>シンボリック実行</h1><p>シンボリック実行とは，プログラムに含まれる変数に具体値を入力せず，その代わりとして値を代表するシンボルの操作を通じてプログラムを模擬的に実行し，結果を評価する技術である．シンボリック実行の目的は，コードカバレッジの拡大にある．シンボリック実行は全てのケースに対してforkする，あるいは，条件分岐の制約をもとにテストケースを生成するといった形態でソフトウェアテストに用いられている．<br>ひとまず，以前書いた<a href="http://ntddk.github.io/2014/09/12/symexec-intro/">シンボリック実行に入門しようとした</a>をご覧頂きたい．</p>
<h1 id="選択的シンボリック実行"><a href="#選択的シンボリック実行" class="headerlink" title="選択的シンボリック実行"></a>選択的シンボリック実行</h1><p>選択的シンボリック実行(selective symbolic execution)は，シンボリック実行の弱点を改善すべく<a href="https://github.com/dslab-epfl/s2e" target="_blank" rel="external">S2E</a>にて提案，実装された．<br>シンボリック実行には実行パスにおける計算爆発(path explosion)の問題があった．プログラム中の全ての実行パスを通るための制約はあまりにも多い．そして，<strong>全ての実行パスというのは解析対象の実行パスだけではない</strong>．考えてもみよう，実システムでプログラムを実行した際，プログラムは自身以外の様々なものを呼び出す．呼び出されるlibcなどのライブラリ，そしてカーネルやデバイスドライバ，さらにそのファームウェアは，一体どこまで解析対象における実行パスの分岐に影響を与えるのか．<br>この頭が痛い問題に対応するべく編み出されたのが選択的シンボリック実行，すなわちシンボリック実行を行う範囲の限定である．S2Eはシンボリック実行を行いたい部分以外に具体値(concrete value)を用いることで，解析対象のプログラムだけにシンボリック実行を適用する(concolic testing)．具体的には，S2Eは指定した変数が使用されている部分のみシンボリック実行を適用している．</p>
<h1 id="S2E"><a href="#S2E" class="headerlink" title="S2E"></a>S2E</h1><h2 id="動的バイナリ変換"><a href="#動的バイナリ変換" class="headerlink" title="動的バイナリ変換"></a>動的バイナリ変換</h2><p>S2Eは，QEMUをベースに開発された．QEMUはエミュレーションを実現するべく，以下のような流れで動的バイナリ変換を行う．</p>
<p>1.ゲストコードの逆アセンブル<br>2.マイクロオペレーションに変換<br>3.コード辞書を参照してホストコードに変換</p>
<p>S2Eはこのコード辞書をLLVM bitcodeに差し替えることで，x86のバイナリをLLVM bitcodeに変換する．そして，変換後のLLVM bitcodeをKLEEに渡すことで，シンボリック実行を行う．<br>このとき，<strong>解析対象の全部分がLLVM bitcodeに変換されるわけではない</strong>．<br><img src="/image/symexec-s2e_01.jpg"><br>指定した変数が使用されている部分のみシンボリック実行を適用すると書いたように，S2Eはシンボル化したデータにアクセスしているか否かによって，解析対象の実行方式を切り替えている．実行方式は以下の二通りだ．</p>
<ol>
<li>具体値にアクセスしている場合，通常通り実行</li>
<li>シンボルにアクセスしている場合，LLVM bitcodeに変換してKLEE上で実行</li>
</ol>
<p>これは，解析対象を多数のコードブロックに分割するというQEMUのバイナリ変換方式に極めて依存している．</p>
<h2 id="S2E-opcodes"><a href="#S2E-opcodes" class="headerlink" title="S2E opcodes"></a>S2E opcodes</h2><p>S2Eは独自の拡張命令S2E opcodesを用いてシンボリック実行のための機能をinstrumentする．S2E opcodesは以下のような機能を提供する．</p>
<ul>
<li><code>S2SYM</code>: データのシンボル化</li>
<li><code>S2ENA</code>: 複数パスの実行を有効化</li>
<li><code>S2DIS</code>: 複数パスの実行を無効化</li>
<li><code>S2OUT</code>: デバッグ情報の出力</li>
</ul>
<p>この中身は<code>s2e-x86.h</code>や<code>s2e.h</code>に記述されている．例として<code>S2SYM</code>の実装を見てみよう．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#define S2E_INSTRUCTION_COMPLEX(val1, val2)             \</div><div class="line">    &quot;.byte 0x0F, 0x3F\n&quot;                                \</div><div class="line">    &quot;.byte 0x00, 0x&quot; #val1 &quot;, 0x&quot; #val2 &quot;, 0x00\n&quot;      \</div><div class="line">    &quot;.byte 0x00, 0x00, 0x00, 0x00\n&quot;</div><div class="line"></div><div class="line">#define S2E_INSTRUCTION_SIMPLE(val)                     \</div><div class="line">    S2E_INSTRUCTION_COMPLEX(val, 00)</div><div class="line"></div><div class="line">~ 略 ~</div><div class="line"></div><div class="line">static inline void s2e_make_symbolic(void *buf, int size, const char *name)</div><div class="line">&#123;</div><div class="line">    __s2e_touch_string(name);</div><div class="line">    __s2e_touch_buffer(buf, size);</div><div class="line"></div><div class="line">    __asm__ __volatile__(</div><div class="line">        S2E_INSTRUCTION_SIMPLE(03)</div><div class="line">        : : &quot;a&quot; (buf), &quot;d&quot; (size), &quot;c&quot; (name) : &quot;memory&quot;</div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>例えば，解析対象のソースコード上で<code>s2e_make_symbolic()</code>の引数にシンボル化したい変数を渡すことで，この関数を利用することができる．</p>
<h2 id="Windowsデバイスドライバに対する選択的シンボリック実行"><a href="#Windowsデバイスドライバに対する選択的シンボリック実行" class="headerlink" title="Windowsデバイスドライバに対する選択的シンボリック実行"></a>Windowsデバイスドライバに対する選択的シンボリック実行</h2><p><a href="https://dslabredmine.epfl.ch/embedded/s2e/Windows/DriverTutorial.html" target="_blank" rel="external">Analyzing Windows Drivers: Step-by-Step Tutorial</a>という公式チュートリアルでは，プラグインを用いてWindowsデバイスドライバにアノテーションを付加する方法が紹介されている．<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function annotation_example(state, plg)</div><div class="line">   -- Write custom Lua code here (e.g., to inject symbolic values)</div><div class="line">end</div><div class="line"></div><div class="line">pluginsConfig.Annotation =</div><div class="line">&#123;</div><div class="line">    init1 = &#123;</div><div class="line">        active=true,</div><div class="line">        module=&quot;pcntpci5_sys_1&quot;,</div><div class="line">        address=0x169c9,</div><div class="line">        instructionAnnotation=&quot;annotation_example&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>チュートリアルの例ではpcntpci5.sysというドライバが0x169c9というアドレスを呼び出す際に<code>annotation_example()</code>が実行される．BSoDもフックできるので，NotMyFaultドライバで遊ぼう．</p>
<h2 id="オーバーヘッド"><a href="#オーバーヘッド" class="headerlink" title="オーバーヘッド"></a>オーバーヘッド</h2><p>いつだって問題となるのは実行速度だ．論文によると，S2Eは具体値による実行時(concrete mode)にQEMUの6倍，シンボリック実行時にQEMUの78倍のオーバーヘッドが生ずるとされている．注意したいのは，実機の78倍ではなくQEMUの78倍である点だ．</p>
<h1 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h1><p>S2Eについて紹介した．<br>このエントリは<a href="http://connpass.com/event/9500/" target="_blank" rel="external">ソフトウェアテストあどべんとかれんだー2014</a>の3日目として書かれた．</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>より詳しくは以下の論文を参照されたい．これも全てVitaly Chipounovって奴の仕業なんだ．</p>
<ul>
<li>Vitaly Chipounov, George Candea,<br>“<a href="http://infoscience.epfl.ch/record/149975/files/x86-llvm-translator-chipounov_2.pdf" target="_blank" rel="external">Dynamically Translating x86 to LLVM using QEMU[PDF]</a>,”<br>Technical Report EPFL-TR-149975, Ecole Polytechnique Fédérale de Lausanne, Switzerland, March 2010.</li>
<li>Volodymyr Kuznetsov, Vitaly Chipounov, George Candea,<br>“<a href="http://dslab.epfl.ch/pubs/ddt.pdf" target="_blank" rel="external">Testing Closed-Source Binary Device Drivers with DDT[PDF]</a>,”<br>Proceedings of the 2010 USENIX conference on USENIX annual technical conference, pp.12-12, Boston, MA, June 2010.</li>
<li>Vitaly Chipounov, Volodymyr Kuznetsov, George Candea,<br>“<a href="http://dslab.epfl.ch/pubs/s2e.pdf" target="_blank" rel="external">S2E: a platform for in-vivo multi-path analysis of software systems[PDF]</a>,”<br>Proceedings of the sixteenth international conference on Architectural support for programming languages and operating systems, pp.265-278, Newport Beach, CA, March 2011.</li>
<li>Vitaly Chipounov, Volodymyr Kuznetsov George Candea,<br>“<a href="http://dslab.epfl.ch/pubs/s2e-tocs.pdf" target="_blank" rel="external">The S2E Platform: Design, Implementation, and Applications[PDF]</a>,”<br>ACM Transactions on Computer Systems, Volume 30, Issue 1, Article No. 2, February 2012.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2014/12/03/symexec-s2e/" data-id="cj9qzc73h0013eu7tpxz9ka7q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-binary-translation/">dynamic binary translation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/symbolic-execution/">symbolic execution</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vine-howto" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2014/09/28/vine-howto/">Vineを動かす</a>
  

      </header>
    
    <time class="article-date" datetime="2014-09-27T20:56:08.000Z" itemprop="datePublished">09-28-2014</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>ここでは，<a href="http://bitblaze.cs.berkeley.edu/" target="_blank" rel="external">BitBlaze</a>のうち，静的解析に特化したコンポーネントであるVineを動かしてみる．</p>
<h1 id="BitBlaze"><a href="#BitBlaze" class="headerlink" title="BitBlaze"></a>BitBlaze</h1><p>BitBlazeはDawn Songらによるバイナリ解析プラットフォームで，2008年に<a href="http://bitblaze.cs.berkeley.edu/papers/bitblaze_iciss08.pdf" target="_blank" rel="external">BitBlaze: A New Approach to Computer Security via Binary Analysis [PDF]</a>が発表されて以来，数多くの研究に用いられてきた．BitBlazeは，動的解析コンポーネントの<a href="http://bitblaze.cs.berkeley.edu/temu.html" target="_blank" rel="external">TEMU</a>，静的解析コンポーネントの<a href="http://bitblaze.cs.berkeley.edu/vine.html" target="_blank" rel="external">Vine</a>，動的シンボリック実行コンポーネントの<a href="http://bitblaze.cs.berkeley.edu/rudder.html" target="_blank" rel="external">Rudder</a>から構成される．このうち，TEMUとVineのソースコードが公開されている．</p>
<h2 id="TEMU-The-BitBlaze-Dynamic-Analysis-Component"><a href="#TEMU-The-BitBlaze-Dynamic-Analysis-Component" class="headerlink" title="TEMU: The BitBlaze Dynamic Analysis Component"></a>TEMU: The BitBlaze Dynamic Analysis Component</h2><p>TEMUはQEMUをベースとしたエミュレータで，テイント解析(taint analysis)の機能を備えている．テイント解析とは，タグを設定したデータの伝搬を追跡することで，データ同士の依存関係を解析する技術である．TEMUはtracecapというプラグインを用いて，ゲストOS上で動作するアプリケーションのトレースログを取得することができる．</p>
<h2 id="Vine-The-BitBlaze-Static-Analysis-Component"><a href="#Vine-The-BitBlaze-Static-Analysis-Component" class="headerlink" title="Vine: The BitBlaze Static Analysis Component"></a>Vine: The BitBlaze Static Analysis Component</h2><p>Vineは，逆アセンブリやTEMUのトレースファイルから，中間表現VineILや最弱事前条件，STP formulaなどを出力する．公開されているVineには，TEMU/tracecapのトレースファイルとしてfive.traceが同梱されている．これを例にVineの機能を見てみよう．</p>
<h1 id="Vineのインストール"><a href="#Vineのインストール" class="headerlink" title="Vineのインストール"></a>Vineのインストール</h1><p><a href="http://bitblaze.cs.berkeley.edu/release/vine-1.0/howto.html" target="_blank" rel="external">Vine installation and user manual</a>の通り．OCamlで記述されているため，関連のパッケージを導入する必要がある．また，32bit環境での動作を前提としている．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install g++ ocaml ocaml-findlib libgdome2-ocaml-dev camlidl \ </div><div class="line">                     libextlib-ocaml-dev ocaml-native-compilers \ </div><div class="line">                     libocamlgraph-ocaml-dev binutils-dev texlive \ </div><div class="line">                     texlive-latex-extra transfig hevea</div></pre></td></tr></table></figure>
<h1 id="trace-reader"><a href="#trace-reader" class="headerlink" title="trace_reader"></a>trace_reader</h1><p>TEMU/tracecapが出力するトレースファイルはhuman-readableではなく，閲覧はVineのtrace_readerを介して行う必要がある．five.traceでは，T1がタグの識別子となっており，T0はデータに設定されたタグが存在しないことを意味する．なお，ここではキーボードからの入力にタグが設定されている．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">../trace_utils/trace_reader -trace five.trace | grep T1 | head -n 20</div><div class="line">42075911:	movzbl (%eax),%eax	R@eax[0x40014000][4]	T0	M@0x40014000[0x00000035][1]	T1 &#123;1 (1001, 0) ()()()&#125;</div><div class="line">42077e0c:	cmp    $0xffffffff,%eax	I@0x00000000[0xffffffff][1]	T0	R@eax[0x00000035][4]	T1 &#123;1 (1001, 0) ()()()&#125;</div><div class="line">42077e14:	movzbl (%edx),%eax	R@eax[0x00000035][4]	T1 &#123;1 (1001, 0) ()()()&#125;	M@0x40014000[0x00000035][1]	T1 &#123;1 (1001, 0) ()()()&#125;</div><div class="line">4205abc5:	mov    %eax,-0xac(%ebp)	R@eax[0x00000035][4]	T1 &#123;1 (1001, 0) ()()()&#125;	M@0xbffff69c[0x00000000][4]	T0</div><div class="line">4205abce:	mov    -0xa8(%ebp),%eax	R@eax[0x00000035][4]	T1 &#123;1 (1001, 0) ()()()&#125;	M@0xbffff6a0[0x00000000][4]	T0</div><div class="line">4205abd5:	cmpl   $0xffffffff,-0xac(%ebp)	I@0x00000000[0xffffffff][1]	T0	M@0xbffff69c[0x00000035][4]	T1 &#123;1 (1001, 0) ()()()&#125;</div><div class="line">4205abf5:	mov    -0xac(%ebp),%edx	R@edx[0x40014001][4]	T0	M@0xbffff69c[0x00000035][4]	T1 &#123;1 (1001, 0) ()()()&#125;</div><div class="line">4205ac0b:	cmpl   $0xffffffff,-0xac(%ebp)	I@0x00000000[0xffffffff][1]	T0	M@0xbffff69c[0x00000035][4]	T1 &#123;1 (1001, 0) ()()()&#125;</div><div class="line">4205ac14:	movzbl -0xac(%ebp),%eax	R@eax[0x42130b80][4]	T0	M@0xbffff69c[0x00000035][1]	T1 &#123;1 (1001, 0) ()()()&#125;</div><div class="line">4205ac24:	push   %eax	R@eax[0x00000035][4]	T1 &#123;1 (1001, 0) ()()()&#125;	M@0xbffff604[0x4213030c][4]	T0</div><div class="line">4205ac25:	mov    0x8(%ebp),%eax	R@eax[0x00000035][4]	T1 &#123;1 (1001, 0) ()()()&#125;	M@0xbffff750[0x4212d980][4]	T0</div><div class="line">4207793a:	mov    0xc(%ebp),%edx	R@edx[0x00000035][4]	T1 &#123;1 (1001, 0) ()()()&#125;	M@0xbffff604[0x00000035][4]	T1 &#123;1 (1001, 0) ()()()&#125;</div><div class="line">42077945:	cmp    %dl,-0x1(%eax)	R@dl[0x00000035][1]	T1 &#123;1 (1001, 0) ()()()&#125;	M@0x40014000[0x00000035][1]	T1 &#123;1 (1001, 0) ()()()&#125;</div><div class="line">42077974:	movzbl %dl,%eax	R@dl[0x00000035][1]	T1 &#123;1 (1001, 0) ()()()&#125;	R@eax[0x40014000][4]	T0</div><div class="line">42077960:	cmp    $0xffffffff,%eax	I@0x00000000[0xffffffff][1]	T0	R@eax[0x00000035][4]	T1 &#123;1 (1001, 0) ()()()&#125;</div><div class="line">4205ac39:	movzbl -0x9d(%ebp),%eax	R@eax[0x00000035][4]	T1 &#123;1 (1001, 0) ()()()&#125;	M@0xbffff6ab[0x00000064][1]	T0</div><div class="line">4205c550:	mov    $0xa,%edx	I@0x00000000[0x0000000a][4]	T0	R@edx[0x00000035][4]	T1 &#123;1 (1001, 0) ()()()&#125;</div><div class="line">4205c566:	cmpl   $0xffffffff,-0xac(%ebp)	I@0x00000000[0xffffffff][1]	T0	M@0xbffff69c[0x00000035][4]	T1 &#123;1 (1001, 0) ()()()&#125;</div><div class="line">4205dcd1:	movzbl (%eax),%edi	R@edi[0x00000000][4]	T0	M@0x40014000[0x00000035][1]	T1 &#123;1 (1001, 0) ()()()&#125;</div><div class="line">4205dcd8:	mov    %edi,-0xac(%ebp)	R@edi[0x00000035][4]	T1 &#123;1 (1001, 0) ()()()&#125;	M@0xbffff69c[0x00000035][4]	T1 &#123;1 (1001, 0) ()()()&#125;</div></pre></td></tr></table></figure>
<h1 id="VineIL"><a href="#VineIL" class="headerlink" title="VineIL"></a>VineIL</h1><p>Vineが生成するVineILは静的単一代入形式の中間表現であり，CFGの情報が損なわれることはない．中間表現の生成をinstruction liftingという．なお，VineILはValgrindの中間表現を扱うライブラリVEXをもとに生成される．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">~/vine/examples$ ../trace_utils/appreplay -trace five.trace -ir-out five.ir</div><div class="line">~/vine/examples$ cat five.ir | awk &apos;NR==1000,NR==1020&apos;</div><div class="line">R_CC_OP_16:reg32_t = 0xd:reg32_t;</div><div class="line">T_32t9_1114:reg32_t = cast(T_8t3_1108:reg8_t)U:reg32_t;</div><div class="line">R_CC_DEP1_17:reg32_t = T_32t9_1114:reg32_t;</div><div class="line">R_CC_DEP2_18:reg32_t = 0:reg32_t;</div><div class="line">R_CC_NDEP_19:reg32_t = 0:reg32_t;</div><div class="line">/*eflags thunk: logic*/</div><div class="line"></div><div class="line">R_CF_10:reg1_t = false;</div><div class="line">T_7_1115:reg8_t = cast(T_32t9_1114:reg32_t)L:reg8_t;</div><div class="line">R_PF_11:reg1_t =</div><div class="line">!cast(</div><div class="line">      ((T_7_1115:reg8_t &gt;&gt; 7:reg32_t ^ T_7_1115:reg8_t &gt;&gt; 6:reg32_t)</div><div class="line">         ^ (T_7_1115:reg8_t &gt;&gt; 5:reg32_t ^ T_7_1115:reg8_t &gt;&gt; 4:reg32_t))</div><div class="line">       ^ </div><div class="line">         ((T_7_1115:reg8_t &gt;&gt; 3:reg32_t ^ T_7_1115:reg8_t &gt;&gt; 2:reg32_t)</div><div class="line">            ^ (T_7_1115:reg8_t &gt;&gt; 1:reg32_t ^ T_7_1115:reg8_t))</div><div class="line">         )L:reg1_t;</div><div class="line">R_AF_12:reg1_t = false;</div><div class="line">R_ZF_13:reg1_t = T_32t9_1114:reg32_t == 0:reg32_t;</div><div class="line">R_SF_14:reg1_t = 1:reg32_t == (1:reg32_t &amp; T_32t9_1114:reg32_t &gt;&gt; 7:reg32_t);</div><div class="line">R_OF_15:reg1_t = false;</div></pre></td></tr></table></figure>
<p>出力している行の番号は適当．</p>
<h1 id="最弱事前条件"><a href="#最弱事前条件" class="headerlink" title="最弱事前条件"></a>最弱事前条件</h1><p>最弱事前条件(weakest precondition)はDijkstraによる述語変換意味論の基礎を成す概念である．Sを条件，式をRとした際，最弱事前条件WP(S, R)は，Rを実行する前にS’が成り立っていればSの実行後にSが成り立つ最も弱い条件S’を表す．単純な例だと，以下のように表現される．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">WP(S, x=e) = S[e/x]</div><div class="line">WP(new == org,  new = new+taint) </div><div class="line">=  new+taint == org</div></pre></td></tr></table></figure>
<p>Vineにおける最弱事前条件の出力は，以下のようになる．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">~/vine/examples$ ../trace_utils/appreplay -trace five.trace -wp-out five.wp</div><div class="line">~/vine/examples$ grep let five.wp | head -n 20</div><div class="line">let post_1681:reg1_t = true in</div><div class="line">let R_EAX_1682:reg32_t = 0x40014000:reg32_t in</div><div class="line">let idx_1683:reg32_t = 0x40014000:reg32_t in</div><div class="line">let val_1684:reg8_t = INPUT_1001_0000_61:reg8_t in</div><div class="line">let temp_1685:reg8_t = val_1684:reg8_t &amp; 0xff:reg8_t in</div><div class="line">let temp_1686:reg8_t = temp_1685:reg8_t &gt;&gt; 0:reg8_t in</div><div class="line">let towrite_1688:reg8_t = cast(temp_1686:reg8_t)L:reg8_t in</div><div class="line">let mem_arr_1687:reg8_t[4294967296] =</div><div class="line">    let mem_arr_57[0x40014000:reg32_t]:reg8_t = towrite_1688:reg8_t in</div><div class="line">    mem_arr_57:reg8_t[4294967296]</div><div class="line">in</div><div class="line">let R_EAX_1689:reg32_t = 0x40014000:reg32_t in</div><div class="line">let R_GDT_1690:reg32_t = 0xc02dbd80:reg32_t in</div><div class="line">let R_LDT_1691:reg32_t = 0xc02dcc58:reg32_t in</div><div class="line">let R_DFLAG_1692:reg32_t = 1:reg32_t in</div><div class="line">let T_32t0_1693:reg32_t = R_EAX_1689:reg32_t in</div><div class="line">let T_8t2_1694:reg8_t = mem_arr_1687[0x40014000:reg32_t]:reg8_t in</div><div class="line">let T_32t1_1695:reg32_t = cast(T_8t2_1694:reg8_t)U:reg32_t in</div><div class="line">let R_EAX_1696:reg32_t = T_32t1_1695:reg32_t in</div><div class="line">let temp_1697:reg32_t = R_EAX_1696:reg32_t &amp; 0xffff00ff:reg32_t in</div><div class="line">let temp_1698:reg32_t = cast(0:reg8_t)U:reg32_t in</div><div class="line">let temp_1699:reg32_t = temp_1698:reg32_t &lt;&lt; 8:reg8_t in</div></pre></td></tr></table></figure>
<p>このような手法でソースコードの存在しないバイナリから最弱事前条件を抽出し，仕様書を復元する試みがあるらしい．ゾッとする．</p>
<h1 id="STP-formula"><a href="#STP-formula" class="headerlink" title="STP formula"></a>STP formula</h1><p>Vineは，TEMUのトレースファイルからSTP formulaを出力する．STP formulaとはSMTソルバであるSTP用のフォーマットである．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">~/vine/examples$ ../trace_utils/appreplay -trace five.trace -stp-out five.stp</div><div class="line">~/vine/examples$ head -n 20 five.stp</div><div class="line">% free variables: </div><div class="line">mem_arr_57 : ARRAY BITVECTOR(64) OF BITVECTOR(8);</div><div class="line">INPUT_1001_0000_61 : BITVECTOR(8);</div><div class="line">% end free variables.</div><div class="line"> </div><div class="line"> </div><div class="line">ASSERT( 0bin1 =</div><div class="line">(LET post_1681 =</div><div class="line">    0bin1</div><div class="line">IN</div><div class="line">(LET R_EAX_1682 =</div><div class="line">    0hex40014000</div><div class="line">IN</div><div class="line">(LET idx_1683 =</div><div class="line">    0hex40014000</div><div class="line">IN</div><div class="line">(LET val_1684 =</div><div class="line">    INPUT_1001_0000_61</div><div class="line">IN</div><div class="line">(LET temp_1685 =</div></pre></td></tr></table></figure>
<p>SMTソルバは充足可能性問題を解く．では，ここで与えられる命題とは何か．それは，任意の初期値がトレースファイルの結果と一致するというものだ．STPは命題が充足可能か解こうとし，充足不能であった場合は反例を出力する．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">~/vine/examples$ cat &gt;&gt;five.stp</div><div class="line">QUERY(FALSE);</div><div class="line">COUNTEREXAMPLE;</div></pre></td></tr></table></figure>
<p>ここで出力される反例は，実行経路に影響を与えた入力値となるようだ．five.traceでは，0x35(ASCIIで5)という入力値が分岐に影響を与えている．</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">~/vine/examples$ ../stp/stp five.stp</div><div class="line">Invalid.</div><div class="line">ASSERT( INPUT_1001_0_61  = 0hex35  );</div></pre></td></tr></table></figure>
<p>これはトレースファイルに対する静的なシンボリック実行だと言える．シンボリック実行とは，記号によって表現したプログラムの変数を操作することで，実行経路に影響する制約を抽出する静的解析の手法である．シンボリック実行は到達定義の解析などモデルベーステストの領域で発展してきたが，マルウェアの挙動解析に役立てられないだろうか．</p>
<h1 id="BAP"><a href="#BAP" class="headerlink" title="BAP"></a>BAP</h1><p><a href="http://bap.ece.cmu.edu" target="_blank" rel="external">BAP</a>はDavid BrumleyらによるVineの再実装である．彼らはCMUに所属しており，PPPのメンバーでもある．彼らは脆弱性解析の自動化をmotivationとしてBitBlazeを扱ってきた．BAPはVineをより発展させたプロジェクトであり，逆アセンブリやTEMUのトレースファイルから中間表現BILを生成するほか，CFGのみならずCDG(control dependence graphs)やDDG(data dependence graphs)の出力をサポートしているようだ．</p>
<h1 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h1><p>TEMUのトレースファイルについて，ざっくりVineによる静的解析を行った．とりあえず動かしてみただけなので，コードを噛み砕く必要がある．気になるのはやはり中間表現のフォーマットだ．一度，QEMU，Valgrind，DynamoRIO，LLVM，Vine，BAPなどの中間表現について，対応を整理したほうが良いかもしれない．</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2014/09/28/vine-howto/" data-id="cj9qzc73k001deu7t3tu7bvkc" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-binary-translation/">dynamic binary translation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/symbolic-execution/">symbolic execution</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/taint-analysis/">taint analysis</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-symexec-intro" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2014/09/12/symexec-intro/">シンボリック実行に入門しようとした</a>
  

      </header>
    
    <time class="article-date" datetime="2014-09-11T17:50:52.000Z" itemprop="datePublished">09-12-2014</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>シンボリック実行(symbolic execution)という用語をセキュリティ系の論文でよく見かけるようになった．ここでは，シンボリック実行の基礎となる理論を辿る．筆者はソフトウェアテストの研究には疎く，おそらく本稿には若干以上の誤謬と誤解が含まれているだろう．ぜひ識者の教示を乞いたい．</p>
<h1 id="発祥"><a href="#発祥" class="headerlink" title="発祥"></a>発祥</h1><p>シンボリック実行は主にソフトウェアテストの領域で古くから研究されてきたトピックである．シンボリック実行という用語の初出は遡ること38年前，James C. Kingらによる<a href="https://courses.engr.illinois.edu/cs477/sp2011/king76symbolicexecution.pdf" target="_blank" rel="external">Symbolic Execution and Program Testing [PDF]</a>という論文だ．Dijkstraがgoto文の濫用による大域脱出を批判したのが1968年であり，Guarded Command Languageを提案したのが1975年のことである．この論文が発表された1976年当時はまさに構造化プログラミングというパラダイムがコンピュータサイエンスの世界を席捲していた時代であった．私が生まれる20年以上前のことで，当時の問題意識を肌身で感じることができないのが少し残念に思える．感覚としては白亜紀のようなもので，主要な登場人物もDijkstraやらKnuthやら，恐竜かよ．<br>さて，シンボリック実行とはどのような提案だったか．まず，シンボリック実行の目的は「どの入力値でどの実行経路を通るか特定する」ことである．そのためにはどうすればよいだろうか？シンボリック実行はその名の通り，プログラムの変数をシンボル(記号)として表現する．論文中のスニペットはあまりにも古めかしいので，<a href="http://en.wikipedia.org/wiki/Symbolic_execution" target="_blank" rel="external">Symbolic execution - Wikipedia, the free encyclopedia</a>を例に考えよう．残念ながら日本語記事はないものの，原理は単純明快．</p>
<pre><code>y = read()
y = 2 * y
if (y == 12)
    fail()
print(&quot;OK&quot;)
</code></pre><p>シンボリック実行では入力に具体値を与えない．例えば，変数yに割り当てられる入力値をsというシンボルで表現する．見ての通り，このルーチンはif文で2つの実行経路に分岐するが，この分岐の条件を制約と呼ぶ．ここでの制約は<code>2 * s == 12</code>となる．実行経路を分岐させる条件となる入力値は，式を解けば分かる．言うまでもなく<code>6</code>だ．おっと，これは充足可能性問題というやつじゃないか？その通り，シンボリック実行では制約を解くにあたって制約充足ソルバ(constraint solver)を用いる．ここでは，<code>2 * s == 12</code>という制約が<code>¬s1 ∧ ¬s2 ∧ ¬s3 ∧ ¬s4 ∧ s5 ∧ s6 ∧ ¬s7 ∧ ¬0</code>という連言標準形で表される．<code>2 * s</code>は<code>s1s2s3s4s5s6s70</code>に，<code>12</code>は<code>00001100</code>となる．<br>このように，具体値を与えないまま，必ず1つの実行経路を通る制約(path constraints)を求め，条件分岐に影響する入力値の制約を特定する手法がシンボリック実行である．シンボリック「実行」と銘打っていても，実際にプログラムを実行しているわけではない．飽くまでシンボルの操作を通して，擬似的にプログラムを実行しているのだ．</p>
<h1 id="Concolic-Testing-Dynamic-Symbolic-Execution"><a href="#Concolic-Testing-Dynamic-Symbolic-Execution" class="headerlink" title="Concolic Testing/Dynamic Symbolic Execution"></a>Concolic Testing/Dynamic Symbolic Execution</h1><p>では，シンボリック実行は銀の弾丸たりえるか？そんなわけがない．真っ先に以下の課題に直面してしまう．</p>
<ul>
<li>計算爆発</li>
<li>制約充足ソルバで解くことができない制約</li>
<li>入力値が一意に定まらない</li>
</ul>
<p>そこで，<a href="http://mir.cs.illinois.edu/marinov/publications/SenETAL05CUTE.pdf" target="_blank" rel="external">CUTE: A Concolic Unit Testing Engine for C [PDF]</a>において，concolic testingという手法が提案された．concolicとは耳慣れない言葉だが，どういった意味だろうか？これは，symbolic(シンボル)とconcrete(具体値)からなる造語で，concolic testingとはシンボリック実行に具体値(concrete value)を持ち込んだ手法である．またの名を動的シンボリック実行．<br>具体値を持ち込むとはどういうことか？動的シンボリック実行では，制約充足ソルバが不得手とする非線形な制約に到達した場合，その箇所だけ実際に実行(concrete execution)することで，具体値を代入する．これによって，コードカバレッジを拡大するというのが狙いである．現在「シンボリック実行」と呼ばれているのは概ね動的シンボリック実行である．</p>
<h1 id="KLEE"><a href="#KLEE" class="headerlink" title="KLEE"></a>KLEE</h1><p><a href="http://klee.github.io/klee/" target="_blank" rel="external">KLEE</a>はシンボリック実行にLLVM bitcodeを導入したプロジェクトである．チュートリアルは<a href="http://feliam.wordpress.com/2010/10/07/the-symbolic-maze/" target="_blank" rel="external">The Symbolic Maze! - Feliam’s Blog</a>が秀逸．<br>使い方は簡単で，解析対象のソースコードに<code>#include &lt;klee/klee.h&gt;</code>と<code>klee_make_symbolic()</code>とを追加するだけで準備は完了する．<code>klee_make_symbolic()</code>にはシンボリック実行を適用したい変数のアドレスとサイズ，名前を引数として与える．</p>
<pre><code>llvm-gcc --emit-llvm -c -g [file].c
klee [file].o
</code></pre><p>LLVM bitcodeとしてコンパイルし，KLEEに与えて実行すると，ktestという形式のテストケースが生成される．</p>
<pre><code>ktest-tool --write-ints klee-last/[file].ktest 
</code></pre><p>ktest-toolを実行すると，入力値が出力される．</p>
<pre><code>ktest file : ‘klee-last/test000001.ktest’
args : [&apos;[file].o&apos;]
num objects: 1
object 0: name: ‘hoge’
object 0: size: 4
object 0: data: ‘fuga′
</code></pre><p>これによって，KLEEは90%以上のコードカバレッジを実現する．論文の評価実験では，Coreutilsについて，15年に渡って作成されてきたテストスイートよりも高いカバレッジをたったの89時間で達成している．<br>KLEEは多くの研究者に利用されており，シンボリック実行に関する研究のstate-of-the-artはKLEEを分散化した<a href="https://code.comsys.rwth-aachen.de/redmine/projects/kleenet-public" target="_blank" rel="external">KleeNet</a>だと聞いている．<br>しかし，もちろんKLEEは万能ではない．特にループ文の解釈がうまくいかないことが多く，これはシンボリック実行が抱える永年の課題である．</p>
<h1 id="STP"><a href="#STP" class="headerlink" title="STP"></a>STP</h1><p>KLEEは<a href="https://sites.google.com/site/stpfastprover/" target="_blank" rel="external">STP Constraint Solver</a>という制約充足ソルバを用いている．STPは制約充足ソルバの中でもSMT(Satisfiable Modulo Theories)ソルバと呼ばれるものに相当する．SAT(SATisfiability problem)ソルバはブール式のみを扱うが，SMTソルバはこれに加えて配列やビットベクトル，加減算大小比較など様々な背景理論を用いることができる．STPではAND，OR，NOT，XORといった演算についてもサポートされ，式の最適化についても工夫されているようだ．</p>
<h1 id="S2E"><a href="#S2E" class="headerlink" title="S2E"></a>S2E</h1><p>少しばかり，リバースエンジニアリングにも目を向けてみよう．解析対象のソースコードが存在しない場合，どうやってシンボリック実行を適用すればよいだろうか？解決策のひとつとして挙げられるのが<a href="https://github.com/dslab-epfl/s2e" target="_blank" rel="external">S2E</a>である．<br>S2EはQEMUの動的バイナリ変換(dynamic binary translation)を用いる．QEMUの動的バイナリ変換機能をTCG(Tiny Code Generator)といい，これによって例えばARM向けにビルドされたバイナリをx86の計算機で動かすといった機能が実現される．<br>まず，QEMUは対象のバイナリを逆アセンブルし，複数のブロックに分割する．このブロックをTB(translation block)といい，定義は<code>translate-all.h</code>に記述されている．TBは分岐命令やページの境界によって区切られる．そして，ブロック単位で逆アセンブルしたコードを<code>gen_intermediate_code()</code>という関数で中間コードに変換し，<code>tcg_gen_code()</code>という関数で他のアーキテクチャの命令とマッピングする．これらは<code>target-[arch]/translate.c</code>および<code>tcg/tgc.c</code>に記述されている．こうして変換されたコードは，TB単位でキャッシュされる．実行にあたっては，変換されたTBをchainとして繋いでいく．この処理は，<code>main()</code>から<code>cpu_exec()</code>を経由して呼ばれる<code>tb_find_fast()</code>や<code>tb_find_slow()</code>に記述されている．こうして，QEMUは異なるアーキテクチャ向けバイナリの実行を可能にしている．<br>S2Eは，QEMUのTCGを用いてPEファイルをLLVM bitcodeに変換し，KLEEに受け渡す．TCGは，中間コードを変換するにあたって，変換先のアーキテクチャの命令が記述された辞書を参照する．S2Eはこの辞書にLLVM bitcodeを登録することで，実行ファイルをLLVM bitcodeに「逆アセンブル」するのだ．<br>このようにして，S2Eはシンボリック実行を実現しているが，そもそもLLVM bitcodeに変換する必要はあるのだろうか？KLEEは確かに優れたツールだが，バイナリに直接シンボリック実行を適用すれば良いのではないか？<br>これには理由がある．QEMUの中間コードも，LLVM bitcodeもレジスタが無限個存在するSSA(Static Single Assignment form，静的単一代入)形式をとっている．一方で，x86アーキテクチャはSSA形式ではない．x86における逆アセンブルコードにシンボリック実行を適用する例を考えよう．</p>
<pre><code>mov esi, 0x09
mov edx, 0x2014
</code></pre><p>この場合，制約は<code>(esi == 0x09) and (edx == 0x2014)</code>となる．これなら問題はないが，以下の例はどうだろう．</p>
<pre><code>mov esi, 0x09
...
mov esi, 0x2014
</code></pre><p>同じレジスタに違う値が代入されている．この場合，制約は<code>(esi == 0x09) and (esi == 0x2014)</code>となってしまう．こうした理由から，シンボリック実行にはSSA形式への変換が必要となるようだ．</p>
<h1 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h1><p>シンボリック実行の基礎を学んだつもりになった．この技術が情報セキュリティの分野でどう活きてくるのかについては，また改めて．進捗だめです．</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="http://debugeng.com/concolic%20testing.pdf" target="_blank" rel="external">Concolic testingと背景技術 ~テスト技法の新動向~ [PDF]</a></li>
<li><a href="http://blog.livedoor.jp/prjmng/archives/52297951.html" target="_blank" rel="external">テスト入力値の自動生成と、concolic testing - ソフトウェアの品質を学びまくる</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2014/09/12/symexec-intro/" data-id="cj9qzc73i0016eu7tt25qagtg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/dynamic-binary-translation/">dynamic binary translation</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/symbolic-execution/">symbolic execution</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-after-rop" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
      <header class="article-header">
        
  
    <a class="article-title" href="/2014/09/11/after-rop/">Return-oriented programming以後</a>
  

      </header>
    
    <time class="article-date" datetime="2014-09-11T10:07:12.000Z" itemprop="datePublished">09-11-2014</time>
    
  </div>
  <div class="article-inner">
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="はじめに"><a href="#はじめに" class="headerlink" title="はじめに"></a>はじめに</h1><p>Return-oriented programming(ROP)が提唱されて久しい．CTFにおいても，ROPは当たり前のように要求される技術となってきている．一方で，ROPに代わる新たな攻撃手法も模索されている．ここでは，そういったROP以後の攻撃手法を概観する．</p>
<h1 id="Return-oriented-programming"><a href="#Return-oriented-programming" class="headerlink" title="Return-oriented programming"></a>Return-oriented programming</h1><h2 id="コンセプト"><a href="#コンセプト" class="headerlink" title="コンセプト"></a>コンセプト</h2><p>まずは簡単にROPをおさらいする．<br>ROPは主にハードウェアDEPという脆弱性対策技術に対抗するために編み出された攻撃手法である．ハードウェアDEPはCPUのNX bitを有効化することで，スタック上でコードを実行する攻撃を無効化する．<br>そこで，ROPはコード領域のretで終わる命令列(gadget)を実行することによってこれを回避する．単体のgadgetではわずかな処理しか行えないが，スタックに次のgadgetのアドレスを積むことで，gadgetを組み合わせたchainを構築することができる．ROPの作成にはコード領域からgadgetを探索する段階とgadgetを組み合わせる段階を要する．レジスタの操作はpopによって行う．</p>
<h2 id="ASLR-PIEの迂回"><a href="#ASLR-PIEの迂回" class="headerlink" title="ASLR/PIEの迂回"></a>ASLR/PIEの迂回</h2><p>ASLRはスタックやヒープなどが読み込まれる位置を実行ごとにランダマイズすることで，アドレスを決め打ちした攻撃を困難にする．だが，ASLRはROPに対処しうる技術ではない．<br>まず，LinuxにおいてASLRはコード領域のランダマイズを行わないため，スタックオーバーフローなどをROPの起点とすることができる．また，bssセグメントに存在する変数のアドレスを取得することができるのは，ASLRの重大な欠陥である．さらに，32bitの場合は総当りによってアドレスを特定できるほか，ulimit -s unlimitedによってASLRを無効化することができる．<br>PIEはASLRに加えてgadgetのアドレスまでランダマイズの対象となるため，攻撃にあたってはleakが前提となる．</p>
<h2 id="RELROの迂回"><a href="#RELROの迂回" class="headerlink" title="RELROの迂回"></a>RELROの迂回</h2><p>RELROはセクションをread onlyに設定する機能である．Partial RELROとFull RELROがあり，前者の場合はGOTを利用した攻撃が可能である．後者の場合はread onlyにしうる全てのセクションがread onlyとなるが，ROPによって攻撃を成立させることができる．</p>
<h2 id="Stager"><a href="#Stager" class="headerlink" title="Stager"></a>Stager</h2><p>攻撃に使える領域のサイズが制限されている場合，readなどの関数を用いて再度メモリに書き込む方法をstagerと呼ぶ．</p>
<h2 id="Stack-Pivot"><a href="#Stack-Pivot" class="headerlink" title="Stack Pivot"></a>Stack Pivot</h2><p>スタックのサイズ上，リターンアドレスの下にROP chainを構築できないような場合，xchg esp,eaxなどのgadgetを用いてスタックのアドレスを移動させる方法をstack pivotと呼ぶ．</p>
<h2 id="論文"><a href="#論文" class="headerlink" title="論文"></a>論文</h2><ul>
<li><a href="http://cseweb.ucsd.edu/~hovav/dist/geometry.pdf" target="_blank" rel="external">The Geometry of Innocent Flesh on the Bone: Return-into-libc without Function Calls (on the x86) [PDF]</a></li>
</ul>
<h1 id="BROP-Blind-return-oriented-programming"><a href="#BROP-Blind-return-oriented-programming" class="headerlink" title="BROP: Blind return-oriented programming"></a>BROP: Blind return-oriented programming</h1><h2 id="コンセプト-1"><a href="#コンセプト-1" class="headerlink" title="コンセプト"></a>コンセプト</h2><p>以下の要件を満たすサーバープログラムの場合は，バイナリが手元になくてもROPを試みることができる．</p>
<ul>
<li>listen，forkを行う</li>
<li>スタックオーバーフローで子プロセスが落ちた場合も動き続ける</li>
<li>GOTにstrcmpなど第三引数を操作できる関数が存在する</li>
<li>GOTにwriteなどleakさせることができる関数が存在する</li>
<li>総当りなどでGOTのアドレスが分かる</li>
</ul>
<p>目的は，自身をwriteによってダンプさせることである．<br>まず，リターンアドレスを総当りして，無限ループに陥るようなgadget(STOP gadgetと呼称)を探す．次に，関数にinnvalidな引数を渡した場合であっても，GOTに正しく飛んだ場合はSEGVしないという点に着目し，0x08040000周辺に存在しているはずのGOTセクションの位置を推定する．推定にあたっては，+0x6のアドレスや次のGOTエントリに飛んだ場合もSEGVしないという特性を用いる．そして，fdを総当りするか，多数のコネクションからwriteを探り当てる．<br>GOTエントリは要素数のサイズが同じであるため，スタックのleakからゴリ押しできる，といった内容のようだが，実際のところどうなのだろうか．CTFのネタとしては面白いのではないか．</p>
<h2 id="論文-1"><a href="#論文-1" class="headerlink" title="論文"></a>論文</h2><ul>
<li><a href="http://www.scs.stanford.edu/brop/bittau-brop.pdf" target="_blank" rel="external">Hacking Blind [PDF]</a></li>
</ul>
<h2 id="実例"><a href="#実例" class="headerlink" title="実例"></a>実例</h2><ul>
<li><a href="http://www.scs.stanford.edu/brop/braille.rb" target="_blank" rel="external">Braille [Ruby]</a></li>
</ul>
<h1 id="SROP-Sigreturn-oriented-Programming"><a href="#SROP-Sigreturn-oriented-Programming" class="headerlink" title="SROP: Sigreturn-oriented Programming"></a>SROP: Sigreturn-oriented Programming</h1><h2 id="コンセプト-2"><a href="#コンセプト-2" class="headerlink" title="コンセプト"></a>コンセプト</h2><p>vdsoには，シグナル割り込みから復帰する際に，ユーザーランドのスタック上に作成したsignal frameに保存している値を全てのレジスタへ戻すsigreturnという命令が存在する．つまり，popadが廃止されたx64においても，sigreturnによってスタック上の値を複数のレジスタにセットすることができる．これによって，任意のシステムコールを呼び出すことが可能となるほか，関数の呼び出しがレジスタ渡しの場合においてもROPが容易になる．なお，vsyscallはASLRが有効であっても固定アドレスである．<br>ulimit -s unlimitedを用いてvdsoのマッピングアドレスを固定できる場合はCTFでも活用できそうだ．</p>
<h2 id="論文-2"><a href="#論文-2" class="headerlink" title="論文"></a>論文</h2><ul>
<li><a href="https://www.cs.vu.nl/~herbertb/papers/srop_sp14.pdf" target="_blank" rel="external">Framing Signals—A Return to Portable Shellcode [PDF]</a></li>
</ul>
<h2 id="実例-1"><a href="#実例-1" class="headerlink" title="実例"></a>実例</h2><ul>
<li><a href="http://inaz2.hatenablog.com/entry/2014/07/30/021123" target="_blank" rel="external">x64でSigreturn Oriented ProgrammingによるASLR+DEP+RELRO回避をやってみる - ももいろテクノロジー</a></li>
</ul>
<h1 id="JOP-Jump-oriented-programmingとCOP-Call-oriented-programming"><a href="#JOP-Jump-oriented-programmingとCOP-Call-oriented-programming" class="headerlink" title="JOP: Jump-oriented programmingとCOP: Call-oriented programming"></a>JOP: Jump-oriented programmingとCOP: Call-oriented programming</h1><h2 id="コンセプト-3"><a href="#コンセプト-3" class="headerlink" title="コンセプト"></a>コンセプト</h2><p>通常，retの次にはそのサブルーチンを呼び出したcallの次の命令が存在する．そこで，コールスタックを辿ることでROPによってretが使われていないか検出するROPguardが考案された．ROPguardはMicrosoftの脆弱性対策ツールであるEMET 3.5の根幹を成す理論だった．<br>そこで，retの代わりにjmpを用いるJump-oriented programmingが考案された．また，retやjmpの代わりにcallを用いるCall-oriented programmingも可能である．例えば以下のコードスニペットにおいて，callはjmpと実質的に等価である．</p>
<pre><code>pop esi;
ret;
push eax;
call esi;

; call先
pop esi ;retアドレスを除去
;eaxを用いる処理
</code></pre><p>COPでは，pushのような表現力の高い命令を用いることができる．</p>
<h2 id="論文-3"><a href="#論文-3" class="headerlink" title="論文"></a>論文</h2><h3 id="ROPguard"><a href="#ROPguard" class="headerlink" title="ROPguard"></a>ROPguard</h3><ul>
<li><a href="http://ifsec.blogspot.jp/2012/08/my-bluehat-prize-entry-ropguard-runtime.html" target="_blank" rel="external">My BlueHat Prize entry: ROPGuard - runtime prevention of return-oriented programming attacks - Ivan Fratric’s Security Blog</a></li>
</ul>
<h3 id="JOP"><a href="#JOP" class="headerlink" title="JOP"></a>JOP</h3><ul>
<li><a href="ftp://ftp.ncsu.edu/pub/tech/2010/TR-2010-8.pdf" target="_blank" rel="external">Jump-Oriented Programming: A New Class of Code-Reuse Attack [PDF]</a></li>
</ul>
<h3 id="COP"><a href="#COP" class="headerlink" title="COP"></a>COP</h3><ul>
<li><a href="http://www.cs.stevens.edu/~gportoka/files/outofcontrol_oakland14.pdf" target="_blank" rel="external">Out of control: Overcoming control-flow integrity [PDF]</a></li>
<li><a href="http://www.cs.berkeley.edu/~daw/papers/rop-usenix14.pdf" target="_blank" rel="external">ROP is Still Dangerous: Breaking Modern Defenses [PDF]</a></li>
</ul>
<h2 id="実例-2"><a href="#実例-2" class="headerlink" title="実例"></a>実例</h2><h3 id="COP-1"><a href="#COP-1" class="headerlink" title="COP"></a>COP</h3><ul>
<li><a href="http://potetisensei.hatenablog.com/entry/2014/09/12/020720" target="_blank" rel="external">Call Oriented Programming - 生きたい</a></li>
</ul>
<h1 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h1><p>ざっとROP以後の攻撃手法を列挙した．これ以外にも，AlphanumericなROPを作成する技術やバイナリから自動的にROPを作成する技術などが研究されている．また，<a href="http://inaz2.hatenablog.com/entry/2014/08/03/230528" target="_blank" rel="external">roputils</a>や<a href="http://bap.ece.cmu.edu/" target="_blank" rel="external">BAP</a>など，ROPを支援するフレームワークも開発されている．これらについてもいずれ理解したい．</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ntddk.github.io/2014/09/11/after-rop/" data-id="cj9qzc7320002eu7tn1vhhr8g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/exploitation/">exploitation</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 ntddk<br>
      <a href="https://github.com/ntddk/hexo-theme-jathena" target="_blank">JAthena</a> by <a href="https://ntddk.github.io" target="_blank">ntddk</a> | Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
  </div>

<!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
</body>
</html>